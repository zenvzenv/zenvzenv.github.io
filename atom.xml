<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZENV</title>
  
  
  <link href="https://zenvzenv.github.io/atom.xml" rel="self"/>
  
  <link href="https://zenvzenv.github.io/"/>
  <updated>2025-04-24T23:20:55.000Z</updated>
  <id>https://zenvzenv.github.io/</id>
  
  <author>
    <name>zenv</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【macOS】如何在macOS上使用whisper来为视频添加字幕</title>
    <link href="https://zenvzenv.github.io/2025/04/22/%E3%80%90macOS%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8macOS%E4%B8%8A%E4%BD%BF%E7%94%A8whisper%E6%9D%A5%E4%B8%BA%E8%A7%86%E9%A2%91%E6%B7%BB%E5%8A%A0%E5%AD%97%E5%B9%95/"/>
    <id>https://zenvzenv.github.io/2025/04/22/%E3%80%90macOS%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8macOS%E4%B8%8A%E4%BD%BF%E7%94%A8whisper%E6%9D%A5%E4%B8%BA%E8%A7%86%E9%A2%91%E6%B7%BB%E5%8A%A0%E5%AD%97%E5%B9%95/</id>
    <published>2025-04-22T14:47:15.000Z</published>
    <updated>2025-04-24T23:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<iframe width="760" height="427"src="https://www.youtube.com/embed/rqRyJ9H8LHI"frameborder="0"allowfullscreen></iframe><p>在<a href="https://zenvzenv.github.io/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/">这篇文章</a>中我介绍了如何在 Windows 上使用 Subtitle Edit 自动识别视频字幕并生成 srt 字幕文件。</p><p>今天我将为大家带来 macOS 系统如何使用 whisper 大模型来为视频自动识别字幕。</p><h2 id="安装-anaconda-（推荐）"><a href="#安装-anaconda-（推荐）" class="headerlink" title="安装 anaconda （推荐）"></a>安装 anaconda （推荐）</h2><p>推荐使用 anaconda 来作为 python 的包管理工具。conda 是一个开源的跨平台包管理器和环境管理器，可用于管理 Python 和非 Python 包，例如 C&#x2F;C++ 编译库等。</p><blockquote><p>此处以苹果 M4 芯片为例，其余芯片的安装步骤请参阅 <a href="https://www.anaconda.com/docs/getting-started/anaconda/install">Installing Anaconda Distribution</a></p></blockquote><ol><li><p>打开终端并运行以下命令之一（取决于您的 macOS 架构）来下载安装程序：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O https://repo.anaconda.com/archive/Anaconda3-2024.10-1-MacOSX-arm64.sh</span><br></pre></td></tr></table></figure></li><li><p>（推荐）验证安装程序的完整性，以确保其在下载过程中未被损坏或篡改。</p><p> 为确保您下载的安装程序未被篡改或损坏，请生成其 SHA-256 哈希值并将其与档案中提供的官方哈希值进行比较。</p><ol><li><p>打开终端输入如下命令：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shasum -a 256 ~/Anaconda3-2024.10-1-MacOSX-arm64.sh</span><br></pre></td></tr></table></figure></li><li><p>注意输出中生成的 SHA-256 哈希值。</p></li><li><p>访问 <a href="https://repo.anaconda.com/archive/">repo.anaconda.com&#x2F;archive</a> 查找安装程序的官方 SHA-256 哈希值。</p></li><li><p>比较哈希值。如果匹配，则安装程序可以安全使用。</p></li></ol></li><li><p>运行以下命令进行安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash ~/Anaconda3-2024.10-1-MacOSX-arm64.sh</span><br></pre></td></tr></table></figure></li><li><p>按回车键查看 Anaconda 的服务条款 (TOS)。然后按住回车键滚动。</p></li><li><p>输入 <code>yes</code> 来确认服务条款</p></li><li><p>按回车键接受默认安装位置 (<code>PREFIX=/Users/&lt;USER&gt;/anaconda3</code>)，或输入其他文件路径指定备用安装目录。安装可能需要几分钟才能完成。</p></li><li><p>选择初始化选项：</p><ol><li><code>Yes</code> - <code>conda</code> 会修改您的 shell 配置，以便在您打开新 shell 时初始化 conda 并自动识别 conda 命令。</li><li><code>No</code> - <code>conda</code> 不会修改您的 Shell 脚本。安装后，如果您需要初始化，则必须手动进行。更多信息，请参阅<a href="https://www.anaconda.com/docs/getting-started/anaconda/install#manual-shell-init-macos">手动 Shell 初始化</a>。</li></ol></li><li><p>安装程序完成并显示，“Thank you for installing Anaconda3!”</p></li><li><p>关闭并重新打开终端窗口以使安装完全生效，或者使用以下命令刷新终端：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><blockquote><p>您还可以控制 Shell 每次打开时是否激活基础环境。以下命令仅在 conda 已初始化的情况下有效：<br>默认开启：<code>conda config --set auto_activate_base True</code><br>默认关闭：<code>conda config --set auto_activate_base False</code></p></blockquote></li><li><p>检查安装状态<br>Anaconda Navigator，即 conda 的图形用户界面 (GUI)，在成功安装 Anaconda 发行版后应该会自动打开。<br>如果没有自动打开，请手动打开该应用程序或使用 CLI 来验证您的安装：</p><ol><li><p>访问您的操作系统的 CLI：</p><ol><li>使用 Cmd+空格键打开 Spotlight 搜索。</li><li>输入“Terminal”并按回车键打开。</li></ol><p> 您应该在命令行提示符中看到 <code>(base)</code>。这表示您已处于基础 conda 环境中。要了解有关环境的更多信息，请参阅环境。</p></li><li><p>运行任意 conda 命令。例如：</p><ul><li><code>conda list</code> - 显示活动环境中安装的软件包及其版本的列表。</li><li><code>anaconda-navigator</code> - 打开 Anaconda Navigator。</li></ul></li></ol></li></ol><p>到此 Anaconda 就算安装完毕了。</p><h2 id="创建-Whisper-专用环境"><a href="#创建-Whisper-专用环境" class="headerlink" title="创建 Whisper 专用环境"></a>创建 Whisper 专用环境</h2><p>由于 <a href="https://github.com/openai/whisper">Whisper</a> 是在 python-3.9.9 环境下进行训练的，所以我们最好也准备相同的环境来安装 Whisper，我们使用如下命令来创建 Whisper 的 python 环境。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 whisper 环境</span></span><br><span class="line">conda create -n whisper python=3.9</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">激活 whisper 环境</span></span><br><span class="line">conda activate whisper</span><br></pre></td></tr></table></figure><p>有了 whisper python 环境之后，我们就可以安装 whisper 了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -U openai-whisper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要将软件包更新到此存储库的最新版本，请运行：</span></span><br><span class="line">pip install --upgrade --no-deps --force-reinstall git+https://github.com/openai/whisper.git</span><br></pre></td></tr></table></figure><p>等待 whisper 的安装完毕。</p><p>它还需要在您的系统上安装命令行工具 <a href="https://ffmpeg.org/">ffmpeg</a>，大多数包管理器都可以提供该工具：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 macOS 上请使用如下命令进行安装</span></span><br><span class="line">brew install ffmpeg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果安装失败并显示“No module named <span class="string">&#x27;setuptools_rust&#x27;</span>”，则需要安装 setuptools_rust，例如运行以下命令：</span></span><br><span class="line">pip install setuptools-rust</span><br></pre></td></tr></table></figure><p>我们可以在终端命令行中输入  <code>whisper --help</code> 来验证 whisper 是否正确安装。如果有帮助手册输出则说明 whisper 安装成功。</p><p>到此 Whisper 就算是安装完毕了。</p><h2 id="可用的-Whisper-模型和语言"><a href="#可用的-Whisper-模型和语言" class="headerlink" title="可用的 Whisper 模型和语言"></a>可用的 Whisper 模型和语言</h2><p>共有六种模型大小，其中四种为纯英语版本，在速度和准确率方面有所取舍。以下列出了可用模型的名称及其相对于大型模型的大致内存需求和推理速度。以下相对速度是通过在 A100 上转录英语语音测得的，实际速度可能会因多种因素（包括语言、语速和可用硬件）而有很大差异。</p><table><thead><tr><th align="center">Size</th><th align="center">Parameters</th><th align="center">English-only model</th><th align="center">Multilingual model</th><th align="center">Required VRAM</th><th align="center">Relative speed</th></tr></thead><tbody><tr><td align="center">tiny</td><td align="center">39 M</td><td align="center"><code>tiny.en</code></td><td align="center"><code>tiny</code></td><td align="center">~1 GB</td><td align="center">~10x</td></tr><tr><td align="center">base</td><td align="center">74 M</td><td align="center"><code>base.en</code></td><td align="center"><code>base</code></td><td align="center">~1 GB</td><td align="center">~7x</td></tr><tr><td align="center">small</td><td align="center">244 M</td><td align="center"><code>small.en</code></td><td align="center"><code>small</code></td><td align="center">~2 GB</td><td align="center">~4x</td></tr><tr><td align="center">medium</td><td align="center">769 M</td><td align="center"><code>medium.en</code></td><td align="center"><code>medium</code></td><td align="center">~5 GB</td><td align="center">~2x</td></tr><tr><td align="center">large</td><td align="center">1550 M</td><td align="center">N&#x2F;A</td><td align="center"><code>large</code></td><td align="center">~10 GB</td><td align="center">1x</td></tr><tr><td align="center">turbo</td><td align="center">809 M</td><td align="center">N&#x2F;A</td><td align="center"><code>turbo</code></td><td align="center">~6 GB</td><td align="center">~8x</td></tr></tbody></table><p>针对中文的字幕识别，我这边推荐使用 <code>medium</code> 模型起步，低于 <code>medium</code> 的话错误后比较多，<code>medium</code> 模型识别出来的字幕错误较少，可以手动进行纠错。</p><h2 id="使用-Whisper-自动识别视频字幕"><a href="#使用-Whisper-自动识别视频字幕" class="headerlink" title="使用 Whisper 自动识别视频字幕"></a>使用 Whisper 自动识别视频字幕</h2><p>首先我们可以使用 <code>whisper --help</code> 来查看 whisper 支持哪些功能。</p><p>我今天主要介绍如何通过 whisper 自动识别没有字幕的视频。</p><ol><li><p>首先需要提取视频的音频</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input_video.mp4 -vn -acodec mp3 output_audio.mp3</span><br></pre></td></tr></table></figure></li><li><p>使用 whisper 识别字幕</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 medium 尺寸的模型对之前提取的音频进行识别，语言类型为中文，输出格式为 srt</span></span><br><span class="line">whisper output_audio.mp3 --model medium --language zh --output_format srt</span><br></pre></td></tr></table></figure></li><li><p>得到 srt 字幕文件之后我们就可以将字幕文件导入到视频剪辑工具中进行字幕微调，修改错别字、修改时间线等。再使用剪辑工具进行视频压制即可得到有字幕的视频。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Whisper 是一个非常好用的开源字幕识别工具，非常适合个人视频内容创作者，大大降低了给视频配字幕的难度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe width=&quot;760&quot; height=&quot;427&quot;
src=&quot;https://www.youtube.com/embed/rqRyJ9H8LHI&quot;frameborder=&quot;0&quot;
allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;在&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="macOS" scheme="https://zenvzenv.github.io/tags/macOS/"/>
    
    <category term="whisper" scheme="https://zenvzenv.github.io/tags/whisper/"/>
    
    <category term="字幕" scheme="https://zenvzenv.github.io/tags/%E5%AD%97%E5%B9%95/"/>
    
    <category term="剪映" scheme="https://zenvzenv.github.io/tags/%E5%89%AA%E6%98%A0/"/>
    
    <category term="大模型" scheme="https://zenvzenv.github.io/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【macOS】macOS上通过UTM安装并配置macOS虚拟机</title>
    <link href="https://zenvzenv.github.io/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://zenvzenv.github.io/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2025-04-13T02:50:00.000Z</published>
    <updated>2025-04-24T23:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<iframe width="760" height="427"src="https://www.youtube.com/embed/t_DiL7tZyso"frameborder="0"allowfullscreen></iframe><h2 id="一、-安装-UTM"><a href="#一、-安装-UTM" class="headerlink" title="一、 安装 UTM"></a>一、 安装 UTM</h2><p>UTM 现在已经上架了苹果的 App Store，但在 App Store 中是收费的，而 UTM 本身是开源软件，因此我们推荐从官网下载免费版本。</p><p>前往 <a href="https://mac.getutm.app/">UTM 官网</a> 或者 <a href="https://github.com/utmapp/UTM/releases">UTM GitHub 发布页面</a> 下载最新的安装包。</p><p>安装包下载完毕之后，我们可以双击进行安装，将 UTM 拖入 Applications 即可完成安装。</p><h2 id="二、-安装-macOS"><a href="#二、-安装-macOS" class="headerlink" title="二、 安装 macOS"></a>二、 安装 macOS</h2><p>UTM 安装完毕之后，就可以着手安装 macOS 虚拟机了。</p><p>由于 <a href="https://mac.getutm.app/gallery/">UTM 自己的虚拟机库</a>中并没有现成的 macOS 虚拟机，那么就需要我们自己手动进行安装。</p><p>我们可以点击创建虚拟机</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%82%B9%E5%87%BB%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="点击创建虚拟机"></p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%82%B9%E5%87%BB%E8%99%9A%E6%8B%9F%E5%8C%96.png" alt="点击虚拟化"></p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%80%89%E6%8B%A9macOS%E7%B3%BB%E7%BB%9F.png" alt="选择macOS系统"></p><p>UTM 支持自己选择 IPSW 来指定虚拟机的 macOS 版本，你可以去 <a href="https://ipsw.me/">ipsw.me</a> 下载你需要的 IPSW 版本；当然你也可以不指定 IPSW 文件，让 UTM 自动下载最新的 macOS 发行版进行安装。</p><blockquote><p>补充说明：<br>IPSW 是苹果系统的发布形态，可以理解为 Windows 的 ISO 文件。<br>如果不手动指定  macOS 系统的话，那么 UTM 会下载最新版 macOS 系统，此时需要注意宿主机的 macOS 版本号与最新的 macOS 系统的 IPSW 的版本号，如果对应不上的话，那么将无法进行安装。<br>如果宿主机的 macOS 的版本号不是最新版，则建议手动下载与宿主机匹配的 macOS 版本。</p></blockquote><p>如果手动指定 IPSW 文件的话，需要在此处选择 IPSW 文件。</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%80%89%E6%8B%A9IPSW%E6%96%87%E4%BB%B6.png" alt="选择IPSW文件"></p><p>如果想让 UTM 自动下载的话则无需进行指定。</p><h2 id="三、-配置虚拟机参数"><a href="#三、-配置虚拟机参数" class="headerlink" title="三、 配置虚拟机参数"></a>三、 配置虚拟机参数</h2><p>接下来需要虚拟机的 CPU 核心数和内存。这两个参数需要根据自己宿主机的实际情况来进行设置，建议给一半的宿主机资源给虚拟机即可，如果你使用虚拟机做一些比较重的工作的话，可以酌情增加资源占用。</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%85%8D%E7%BD%AECPU%E5%92%8C%E5%86%85%E5%AD%98.png" alt="配置CPU和内存"></p><p>配置完 CPU 和内存之后需要配置虚拟机的磁盘大小，在 macOS 安装完毕之后，磁盘会被占用25 GB 左右，因此建议磁盘大小至少大于 30GB。</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%85%8D%E7%BD%AE%E7%A3%81%E7%9B%98%E5%A4%A7%E5%B0%8F.png" alt="配置磁盘大小"></p><p>最后确认虚拟机的配置参数点击保存即可。</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%A1%AE%E8%AE%A4%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0.png" alt="确认虚拟机配置参数"></p><p>确认所有参数无误后，点击“保存”完成配置。</p><h2 id="四、-启动虚拟机并安装-macOS"><a href="#四、-启动虚拟机并安装-macOS" class="headerlink" title="四、 启动虚拟机并安装 macOS"></a>四、 启动虚拟机并安装 macOS</h2><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%BF%90%E8%A1%8C%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="运行虚拟机"></p><p>首次启动虚拟机会提示需要抹掉主驱动器上的系统，因为我们是第一次启动，所以可以直接点击 <code>好</code> 来继续启动虚拟机。</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E6%8F%90%E7%A4%BA.png" alt="首次启动提示"></p><p>等待虚拟机的启动完成，<strong>需要注意的时，此步骤需要网络畅通，否则会初始化失败，如果初始化失败，需要查看自己是否开启了代理</strong></p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%AD%89%E5%BE%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BD%E5%B9%B6%E5%90%AF%E5%8A%A8.png" alt="等待虚拟机加载并启动"></p><p>启动成功之后就是一些常规的 macOS 系统设置。</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE.png" alt="系统配置"></p><p>到此虚拟机就安装完毕了。</p><h2 id="五、-设置虚拟机网络"><a href="#五、-设置虚拟机网络" class="headerlink" title="五、 设置虚拟机网络"></a>五、 设置虚拟机网络</h2><p>右键虚拟机，选择“编辑”可以进入网络设置界面。</p><p>UTM 支持两种网络模式，一种是<strong>共享模式</strong>，另一种是<strong>桥接模式</strong>。</p><p>推荐使用桥接模式，桥接模式下，虚拟机在网络环境中的地位和宿主机是一致的，有和宿主机可以互通的 IP 地址。如果我们在虚拟机上部署了什么服务，宿主机和同一网络下的设备都是可以访问的。</p><p>我们使用 <code>ifocnfig</code> 命令查看宿主机的网络情况，找到 <code>en0</code> 或 <code>en1</code> 的 <code>inet</code> 信息，主要看这两个网卡哪个是正确的局域网 IP。</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C.png" alt="桥接模式网络"></p><p>如果 <code>en0</code> 的 <code>inet</code> 是正确的局域网 IP 地址，那么接口就选择 <code>en0</code>，<code>en1</code> 也是同理。</p><p>设置完网络之后，我们可以再次启动虚拟机来设置虚拟机网络配置信息。我们可以将虚拟机的 IP 设置为静态 IP，那么以后虚拟机的 IP 地址就不会变动，方便以后我们进行管理。</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C.png" alt="虚拟机网络"></p><p>设置相关网络信息</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BAIP%E4%BF%A1%E6%81%AF.png" alt="配置虚拟机IP信息"></p><p>设置完毕之后，最好重启下虚拟机让配置生效，重启之后使用浏览器查看网络是否畅通。</p><h2 id="六、-设置共享文件夹"><a href="#六、-设置共享文件夹" class="headerlink" title="六、 设置共享文件夹"></a>六、 设置共享文件夹</h2><p>宿主机与虚拟机之间的文件传递是非常的重要。</p><p>UTM 提供了简便的共享方式：</p><p>在虚拟机页面的右上角，有共享文件夹按钮，可以直接选择宿主机上的文件夹共享给虚拟机。</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8C%89%E9%92%AE.png" alt="共享文件夹按钮"></p><p>共享文件夹之后，不会立即生效，需要重启虚拟机来生效共享文件的访问。</p><p>虚拟机重启之后在访达中进行查看。</p><p><img src="/2025/04/13/%E3%80%90macOS%E3%80%91macOS%E4%B8%8A%E9%80%9A%E8%BF%87UTM%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmacOS%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9F%A5%E7%9C%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="虚拟机查看共享文件夹"></p><h2 id="七、-总结"><a href="#七、-总结" class="headerlink" title="七、 总结"></a>七、 总结</h2><p>通过以上步骤，我们已成功在 macOS 上使用 UTM 安装并配置了 macOS 虚拟机。虚拟机具备：</p><ul><li>正常联网能力</li><li>与宿主机互通的桥接网络</li><li>静态 IP 地址管理</li><li>文件共享功能</li></ul><p>这套配置适用于日常开发、测试、演示等场景，使用灵活、配置简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe width=&quot;760&quot; height=&quot;427&quot;
src=&quot;https://www.youtube.com/embed/t_DiL7tZyso&quot;frameborder=&quot;0&quot;
allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;一、-安装-UTM</summary>
      
    
    
    
    
    <category term="macOS" scheme="https://zenvzenv.github.io/tags/macOS/"/>
    
    <category term="UTM" scheme="https://zenvzenv.github.io/tags/UTM/"/>
    
    <category term="虚拟机" scheme="https://zenvzenv.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="macOS 虚拟机" scheme="https://zenvzenv.github.io/tags/macOS-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【保姆级教程】在 macOS 上本地部署大模型并通过 OpenWebUI 进行访问</title>
    <link href="https://zenvzenv.github.io/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/"/>
    <id>https://zenvzenv.github.io/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/</id>
    <published>2025-04-05T05:53:15.000Z</published>
    <updated>2025-04-24T23:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前已经写过一份 Windows 部署 DeepSeek-R1 的博客了，但我那台陪我8年的 Windows 老伙计笔记本已经英勇牺牲了，正好乘着国补和教育补贴拿下 32G 内存、256G 硬盘的 Mac mini，也算是鸟枪换炮了。</p><p>这就导致了我之前部署的 DeepSeek 环境也用不了了，这不又来折腾 macOS 的 DeepSeek 的大模型环境</p><p>在本教程中，我们将手把手教你如何在 macOS 上部署 DeepSeek-R1 大模型，并通过 OpenWebUI 进行访问。本教程适合零基础用户，确保每一步都清晰可操作。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装-Ollama"><a href="#安装-Ollama" class="headerlink" title="安装 Ollama"></a>安装 Ollama</h3><ol><li><p>首先访问 <a href="https://ollama.com/">Ollama 官网</a> 来下载 Ollama 安装包</p><blockquote><p>Ollama 官方 GitHub 源代码仓库:<a href="https://github.com/ollama/ollama">https://github.com/ollama/ollama</a></p></blockquote><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E4%B8%8B%E8%BD%BD%E6%8C%89%E9%92%AE.png" alt="下载按钮"></p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/macOS%E4%B8%8B%E8%BD%BD%E6%8C%89%E9%92%AE.png" alt="macOS下载"></p></li><li><p>等待 Ollama 下载完成，待 Ollama 下载完毕之后双击打开压缩包解压出 Ollama 的安装文件</p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E8%A7%A3%E5%8E%8B%E5%87%BA%E7%9A%84%E6%96%87%E4%BB%B6.png" alt="解压出的文件"></p></li><li><p>双击 <code>Ollama</code> 安装文件进行安装</p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E5%85%81%E8%AE%B8%E6%89%93%E5%BC%80%E5%8E%8B%E7%BC%A9%E5%8C%85.png" alt="允许打开压缩包"></p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9B%AE%E5%BD%95.png" alt="移动到应用程序目录"></p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E7%82%B9%E5%87%BB%E4%B8%8B%E4%B8%80%E6%AD%A5.png" alt="点击下一步"></p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E7%82%B9%E5%87%BB%E5%AE%89%E8%A3%85.png" alt="点击安装"></p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E5%B9%B6%E7%BB%A7%E7%BB%AD.png" alt="输入密码并继续"></p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E5%AE%89%E8%A3%85%E7%BB%93%E6%9D%9F.png" alt="安装结束"></p></li><li><p>验证是否安装成功，在终端输入 <code>ollama --version</code> 如果能正确输出版本号则说明安装成功</p></li><li><p>配置 Ollama （可选）</p><ol><li>在 macOS 上 ollama 默认将模型存放的路径是： <code>~/.ollama/models</code>，如果想要修改此配置需要修改环境变量，使用 <code>launchctl setenv OLLAMA_MODELS &quot;/Users/YourUsername/CustomOllamaModels&quot;</code> 来更新环境变量的值</li><li>请将 <code>/Users/YourUsername/CustomOllamaModels</code> 替换为实际的路径</li><li>如果你已有模型，那么可以将现有的模型迁移至新的目录中，使用 <code>cp -R ~/.ollama/models/* /Users/YourUsername/CustomOllamaModels/</code> 命令来进行迁移</li><li>迁移之后需要重启 Ollama，重启之后新配置将会生效</li><li>同理，如果想修改 <code>OLLAMA_HOST</code>, <code>OLLAMA_PORT</code> 等参数的话，也是使用以上的步骤进行修改即可</li></ol></li></ol><h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><ol><li><p>首先访问 <a href="https://www.docker.com/">docker 官网</a>下载 docker 安装包，等待安装包下载完毕。</p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E5%AE%89%E8%A3%85%E7%BB%93%E6%9D%9F.png" alt="安装结束"></p></li><li><p>找到下载好的 <code>Docker.dmg</code> 并拖拽到应用程序目录完成安装</p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E6%8B%96%E6%8B%BD%E5%AE%8C%E6%88%90%E5%AE%89%E8%A3%85docker.png" alt="拖拽完成安装docker"></p></li><li><p>打开 docker，首次打开需要进行设置</p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85docker.png" alt="推荐模式安装docker"></p></li><li><p>跳过登陆</p><p> <img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/docker%E8%B7%B3%E8%BF%87%E7%99%BB%E9%99%86.png" alt="docker跳过登陆"></p></li></ol><h3 id="安装-OpenWebUI"><a href="#安装-OpenWebUI" class="headerlink" title="安装 OpenWebUI"></a>安装 OpenWebUI</h3><blockquote><p>需要科学上网环境，否则 docker 的镜像包拉取会失败</p></blockquote><p>Ollama 就在本地机器的话，可以执行如下命令安装并运行 OpenWebUI</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull ghcr.io/open-webui/open-webui:main</span><br><span class="line">docker run -d -p 3000:8080 -v open-webui:/Users/YourUsername/OpenWebUI --name open-webui ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure><p>启动完毕之后即可访问 <code>http://localhost:3000</code> 来访问 OpenWebUI 界面</p><p><img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E8%81%8A%E5%A4%A9.png" alt="聊天"></p><p>当然也可以在手机中访问 OpenWebUI 的界面</p><p><img src="/2025/04/05/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E5%9C%A8macOS%E4%B8%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%80%9A%E8%BF%87OpenWebUI%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/%E6%89%8B%E6%9C%BA%E4%B8%AD%E8%AE%BF%E9%97%AEOpenWebUI.jpg" alt="手机中访问OpenWebUI"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客只是展示了如何部署 DeepSeek-R1 模型，Ollama 支持多种模型，我们只需要通过 Ollama pull 下到本地即可使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在之前已经写过一份 Windows 部署 DeepSeek-R1 的博客了，但我那台陪我8年的 Windows 老伙计笔记本已经英勇牺牲了，</summary>
      
    
    
    
    
    <category term="macOS" scheme="https://zenvzenv.github.io/tags/macOS/"/>
    
    <category term="大模型" scheme="https://zenvzenv.github.io/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="deepseek" scheme="https://zenvzenv.github.io/tags/deepseek/"/>
    
    <category term="ollama" scheme="https://zenvzenv.github.io/tags/ollama/"/>
    
  </entry>
  
  <entry>
    <title>剪映字幕功能收费？Subtitle Edit自动识别视频字幕可解君愁！</title>
    <link href="https://zenvzenv.github.io/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/"/>
    <id>https://zenvzenv.github.io/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/</id>
    <published>2025-03-05T14:13:04.000Z</published>
    <updated>2025-04-24T23:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<iframe width="760" height="427"src="https://www.youtube.com/embed/0JygNqGsSfE"frameborder="0"allowfullscreen></iframe><p>众所周知，剪映高版本的自动识别视频字幕的功能变成收费的了，在之前的版本中，虽然是收费的但是还是有白嫖的途径，比如在识别完字幕后预览全屏视频全屏播放然后使用录屏软件进行录制；或者找到视频的临时存放目录，找到字幕的 json 文件，在网上找到转义工具也是能白嫖的，但现在这些方式全部失效。</p><p>接下来就为大家介绍本地使用 Subtitle Edit 使用 Whisper 来自动识别视频字幕，本地部署大模型识别视频字幕，隐私更好，可定制性更高。</p><h2 id="Subtitle-Edit-安装"><a href="#Subtitle-Edit-安装" class="headerlink" title="Subtitle Edit 安装"></a>Subtitle Edit 安装</h2><p>Subtitle Edit 是一款开源的字幕编辑器软件，可以利用大模型来帮我我们识别视频中的语音并自动识别成 srt 字幕文件</p><p>我们先去 <a href="https://github.com/SubtitleEdit/subtitleedit/releases">Subtitle Edit 下载页面</a> 下载软件，Subtitle Edit 支持 Windows 和 Linux，我本地是 Windows 系统，我选择下载 <code>SubtitleEdit-4.0.11-Setup.zip</code> 安装包。</p><p>下载完毕之后，解压出安装程序，双击安装包进行安装。此时 Windows 会弹框提示无法识别 Subtitle Edit 软件，这个可以忽略，点击<code>更多信息</code>后再点击<code>仍要运行</code>即可</p><p><img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/windows%E4%BF%9D%E6%8A%A4.png" alt="windows保护"></p><p><img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E4%BB%8D%E8%A6%81%E8%BF%90%E8%A1%8C.png" alt="仍要运行"></p><p>我们选择简体中文进行安装</p><p><img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E5%AE%89%E8%A3%85.png" alt="简体中文安装"></p><p>之后一直点击下一步即可完成安装。</p><p><img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png" alt="安装完成"></p><p>安装完成后，我们勾选 <code>运行 Subtitle Edit</code> 选项来启动 Subtitle Edit，第一次启动需要安装 ffmpeg，安装过程很快，等待自动安装完毕即可。</p><blockquote><p>安装 ffmpeg 需要科学上网</p></blockquote><h2 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a>设置中文</h2><p>我们打开 Subtitle Edit 之后，找到 <code>Options</code> 选项卡，然后找到 <code>Choose language</code> 选项</p><p><img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E4%BF%AE%E6%94%B9%E8%AF%AD%E8%A8%80.png" alt="修改语言"></p><p>下拉选项找到简体中文选项</p><p><img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87.png" alt="简体中文"></p><h2 id="制作字幕"><a href="#制作字幕" class="headerlink" title="制作字幕"></a>制作字幕</h2><p>以上准备工作结束之后，我们就可以开始制作字幕了。</p><ol><li><p>找打 <code>视频</code> 并 <code>打开视频文件</code>，找到需要识别的视频文件，</p><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6.png" alt="打开视频文件"></p><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%92%8C%E9%9F%B3%E8%BD%A8.png" alt="视频播放和音轨"></p></li><li><p>找到 <code>语音识别</code> 选项</p><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB.png" alt="语音识别"></p></li><li><p>第一次打开时会自动下载 <code>Whisper-XXL</code> 引擎，等待下载完成即可</p><blockquote><p>下载语音识别引擎时需要科学上网</p></blockquote><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E5%BC%95%E6%93%8E.png" alt="语音识别引擎"></p></li><li><p>语音识别引擎下载完毕之后，我们需要选择语言模型，如果本地机器性能一般的话，我建议使用 <code>medium</code> 尺寸的模型</p><blockquote><p>下载语言模型时需要科学上网</p></blockquote><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E9%80%89%E6%8B%A9%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B.png" alt="选择语言模型"></p><p> Whisper 有多种尺寸可选，<code>tiny</code>,<code>base</code>,<code>small</code>,<code>medium</code>,<code>large</code>，尺寸越大识别的效果越好，也耗时，这个需要看本地机器的性能，如果有 Nvidia 显卡的话可以加速识别过程。</p><p> 我这边尝试了几种尺寸的模型，<code>tiny</code> 和 <code>base</code> 识别出来的效果一般，很多都没有识别出来；<code>medium</code> 效果还是不错的，比较准确，我只需要进行微调即可；<code>large-v3-turbo</code> 这个我本地没有跑出来，可能是我本地的显卡显存太小导致的。但 <code>medium</code> 识别出来的效果我已经很满意了，也就无所谓了。</p><p> 选择完语言模型之后等待模型下载完毕即可。</p></li><li><p>选择视频文件，可以单个文件生成也可以批量文件生成，然后点击 <code>生成</code> 即可。</p><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E7%94%9F%E6%88%90%E5%AD%97%E5%B9%95.png" alt="生成字幕"></p></li><li><p>等待进度条，将音频转录为文本</p><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E7%AD%89%E5%BE%85%E8%BF%9B%E5%BA%A6%E6%9D%A1.png" alt="等待进度条"></p></li><li><p>字幕生成完毕</p><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E5%AD%97%E5%B9%95%E7%94%9F%E6%88%90%E5%AE%8C%E6%AF%95.png" alt="字幕生成完毕"></p><p> 可以看到左边为字幕，右边为视频</p></li><li><p>微调字幕</p><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E5%BE%AE%E8%B0%83%E5%AD%97%E5%B9%95.png" alt="微调字幕"></p><p> 如果识别出来的字幕有错别字，那么可以在文本中直接修改，如果字幕的时间点对不上也可以手动修改起始时间和持续时长</p></li><li><p>将字幕刻录到视频中</p><p> 如果字幕微调结束，那么我们可以把修改后的字幕直接刻录到视频中</p><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E5%88%BB%E5%BD%95%E5%AD%97%E5%B9%95.png" alt="刻录字幕"></p><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E5%88%BB%E5%BD%95%E4%B8%AD.png" alt="刻录中"></p></li><li><p>刻录完毕之后，打开视频进行查看，可以发现，字幕已经刻录到视频中。</p><p> <img src="/2025/03/05/%E5%89%AA%E6%98%A0%E5%AD%97%E5%B9%95%E5%8A%9F%E8%83%BD%E6%94%B6%E8%B4%B9%EF%BC%9FSubtitle-Edit%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%A7%86%E9%A2%91%E5%AD%97%E5%B9%95%E5%8F%AF%E8%A7%A3%E5%90%9B%E6%84%81%EF%BC%81/%E5%88%BB%E5%BD%95%E6%88%90%E5%8A%9F.png" alt="刻录成功"></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，我们就成功的使用 Subtitle Edit 从视频中识别出字幕并把字幕刻录到视频中，从此字幕不再求人，自己动手丰衣足食。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe width=&quot;760&quot; height=&quot;427&quot;
src=&quot;https://www.youtube.com/embed/0JygNqGsSfE&quot;frameborder=&quot;0&quot;
allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;众所周知，剪映高版本的自动识</summary>
      
    
    
    
    
    <category term="字幕" scheme="https://zenvzenv.github.io/tags/%E5%AD%97%E5%B9%95/"/>
    
    <category term="剪映" scheme="https://zenvzenv.github.io/tags/%E5%89%AA%E6%98%A0/"/>
    
    <category term="大模型" scheme="https://zenvzenv.github.io/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="Subtitle Edit" scheme="https://zenvzenv.github.io/tags/Subtitle-Edit/"/>
    
  </entry>
  
  <entry>
    <title>一文看懂基于Windows搭建Ollama+Docker+OpenWebUI+DeepSeek-R1大模型环境</title>
    <link href="https://zenvzenv.github.io/2025/02/15/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%9F%BA%E4%BA%8EWindows%E6%90%AD%E5%BB%BAOllama-Docker-OpenWebUI-DeepSeek-R1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83/"/>
    <id>https://zenvzenv.github.io/2025/02/15/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%9F%BA%E4%BA%8EWindows%E6%90%AD%E5%BB%BAOllama-Docker-OpenWebUI-DeepSeek-R1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83/</id>
    <published>2025-02-15T08:48:02.000Z</published>
    <updated>2025-04-24T23:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<iframe width="760" height="427"src="https://www.youtube.com/embed/fcquZpYdntQ"frameborder="0"allowfullscreen></iframe><p>本文主要介绍如何在 Windows 环境安装 Ollama 环境，并在 Ollama 环境中部署 DeepSeek 大模型，最终可以在 web ui 中进行访问模型并使用。</p><h2 id="安装与配置-Ollama"><a href="#安装与配置-Ollama" class="headerlink" title="安装与配置 Ollama"></a>安装与配置 Ollama</h2><h3 id="安装-Ollama"><a href="#安装-Ollama" class="headerlink" title="安装 Ollama"></a>安装 Ollama</h3><ol><li><p>访问 <a href="https://ollama.com/">Ollama 官网</a>下载</p><blockquote><p>Ollama 官方 GitHub 源代码仓库:<a href="https://github.com/ollama/ollama">https://github.com/ollama/ollama</a></p></blockquote><p> <img src="/2025/02/15/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%9F%BA%E4%BA%8EWindows%E6%90%AD%E5%BB%BAOllama-Docker-OpenWebUI-DeepSeek-R1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83/%E4%B8%8B%E8%BD%BD%E6%8C%89%E9%92%AE.png" alt="下载按钮"></p><p> <img src="/2025/02/15/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%9F%BA%E4%BA%8EWindows%E6%90%AD%E5%BB%BAOllama-Docker-OpenWebUI-DeepSeek-R1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83/Windows%E4%B8%8B%E8%BD%BD.png" alt="Windows下载"></p></li><li><p>等待 Ollama 下载完成并双击打开下载的文件 <code>OllamaSetup.exe</code>，出现如下弹框，点击 <code>Install</code> 等待下载完成即可</p><p> <img src="/2025/02/15/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%9F%BA%E4%BA%8EWindows%E6%90%AD%E5%BB%BAOllama-Docker-OpenWebUI-DeepSeek-R1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83/%E5%AE%89%E8%A3%85.png" alt="安装"></p></li><li><p>安装完成后，可以看到 Ollama 已经默认自动运行中。可以通过底部的导航栏找到 Ollama 标志。右键 Ollama 图标可以查看运行日志和退出 Ollama。</p><p> <img src="/2025/02/15/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%9F%BA%E4%BA%8EWindows%E6%90%AD%E5%BB%BAOllama-Docker-OpenWebUI-DeepSeek-R1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83/%E5%8F%B3%E9%94%AEOllama%E5%9B%BE%E6%A0%87.png" alt="右键Ollama图标"></p></li></ol><h3 id="配置-Ollama"><a href="#配置-Ollama" class="headerlink" title="配置 Ollama"></a>配置 Ollama</h3><blockquote><p>Ollama可以像其他软件一样在电脑上完成一键安装，不同的是，建议按照实际需求配置下系统环境变量参数。以下是 Ollama 的环境变量配置说明。</p></blockquote><table><thead><tr><th>参数</th><th>标识与配置</th></tr></thead><tbody><tr><td>OLLAMA_MODELS</td><td>表示模型文件的存放目录，默认目录为<strong>当前用户目录</strong>即  <code>C:\Users%username%.ollama\models</code><br />Windows 系统 <strong>建议不要放在C盘</strong>，可放在其他盘（如 <code>E:\ollama\models</code>）</td></tr><tr><td>OLLAMA_HOST</td><td>表示ollama 服务监听的网络地址，默认为<strong>127.0.0.1</strong> <br />如果想要允许其他电脑访问 Ollama（如局域网中的其他电脑），<strong>建议设置</strong>成 <strong>0.0.0.0</strong></td></tr><tr><td>OLLAMA_PORT</td><td>表示ollama 服务监听的默认端口，默认为<strong>11434</strong> <br />如果端口有冲突，可以修改设置成其他端口（如<strong>8080</strong>等）</td></tr><tr><td>OLLAMA_ORIGINS</td><td>表示HTTP 客户端的请求来源，使用半角逗号分隔列表<br />如果本地使用不受限制，可以设置成星号 <code>*</code></td></tr><tr><td>OLLAMA_KEEP_ALIVE</td><td>表示大模型加载到内存中后的存活时间，默认为<strong>5m</strong>即 5 分钟<br />（如纯数字300 代表 300 秒，0 代表处理请求响应后立即卸载模型，任何负数则表示一直存活）<br />建议设置成 <strong>24h</strong> ，即模型在内存中保持 24 小时，提高访问速度</td></tr><tr><td>OLLAMA_NUM_PARALLEL</td><td>表示请求处理的并发数量，默认为<strong>1</strong> （即单并发串行处理请求）<br />建议按照实际需求进行调整</td></tr><tr><td>OLLAMA_MAX_QUEUE</td><td>表示请求队列长度，默认值为<strong>512</strong> <br />建议按照实际需求进行调整，超过队列长度的请求会被抛弃</td></tr><tr><td>OLLAMA_DEBUG</td><td>表示输出 Debug 日志，应用研发阶段可以设置成<strong>1</strong> （即输出详细日志信息，便于排查问题）</td></tr><tr><td>OLLAMA_MAX_LOADED_MODELS</td><td>表示最多同时加载到内存中模型的数量，默认为<strong>1</strong> （即只能有 1 个模型在内存中）</td></tr></tbody></table><p><strong>对于初学者，我们强烈建议你配置 OLLAMA_MODELS 来更改模型存储位置。</strong> 默认情况下，Ollama 模型会存储在 C 盘用户目录下的 .ollama&#x2F;models 文件夹，占用 C 盘空间。 将其更改到其他分区可以更好地管理你的存储。</p><h4 id="步骤一：找到系统环境变量的设置入口"><a href="#步骤一：找到系统环境变量的设置入口" class="headerlink" title="步骤一：找到系统环境变量的设置入口"></a>步骤一：找到系统环境变量的设置入口</h4><p>方法 1：开始-&gt;设置-&gt;关于-&gt;高级系统设置-&gt;系统属性-&gt;环境变量。</p><p>方法 2：此电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量。</p><p>方法 3：开始-&gt;控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;系统属性-&gt;环境变量。</p><p>方法 4：Win+R 打开运行窗口，输入 <code>sysdm.cpl</code>，回车打开系统属性，选择高级选项卡，点击环境变量。</p><h4 id="步骤-2：设置-OLLAMA-MODELS-环境变量-更改模型存储位置"><a href="#步骤-2：设置-OLLAMA-MODELS-环境变量-更改模型存储位置" class="headerlink" title="步骤 2：设置 OLLAMA_MODELS 环境变量 (更改模型存储位置)"></a>步骤 2：设置 <code>OLLAMA_MODELS</code> 环境变量 (更改模型存储位置)</h4><ol><li>在 “<strong>环境变量</strong>” 窗口的 “<strong>系统变量(S)</strong>” 区域 (或者 “用户变量(U)” 区域，根据你的需求选择)，点击 “<strong>新建(W)…</strong>” 按钮。</li><li>在 “<strong>变量名(N)</strong>” 输入框中，输入： <code>OLLAMA_MODELS</code>  (注意大小写，建议全部大写)。</li><li>在 “<strong>变量值(V)</strong>” 输入框中，输入你想要设置的模型存储路径。  <strong>例如，如果你想将模型存储到 E 盘的 <code>ollama\models</code> 文件夹下，你可以在 “变量值(V)” 中输入： <code>E:\ollama\models</code></strong>  (请根据你的实际情况修改盘符和文件夹路径)。<ul><li><strong>注意：</strong>  请确保你输入的路径是 <strong>已经存在的文件夹</strong> 或者 <strong>你希望创建的文件夹的父目录存在</strong>。  Ollama 在首次运行时可能会自动创建 <code>models</code> 文件夹，但最好提前创建好 <code>ollama</code> 文件夹，确保路径的正确性。</li><li><strong>示例：</strong>  为了将模型存储到 E 盘的 <code>ollama\models</code> 文件夹，你可以在 “变量值(V)” 中输入：  <code>E:\ollama\models</code></li></ul></li><li>点击 “<strong>确定</strong>” 按钮，关闭 “<strong>新建系统变量</strong>” (或者 “新建用户变量”) 窗口。</li></ol><blockquote><p><strong>注意：</strong> 如果你不知道如何设置 <code>OLLAMA_MODELS</code> 环境变量，可以参考下面的示例。</p></blockquote><p><img src="/2025/02/15/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%9F%BA%E4%BA%8EWindows%E6%90%AD%E5%BB%BAOllama-Docker-OpenWebUI-DeepSeek-R1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83/%E8%AE%BE%E7%BD%AEOllama%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="设置Ollama环境变量"></p><h4 id="（可选）设置-OLLAMA-HOST-环境变量-修改监听地址"><a href="#（可选）设置-OLLAMA-HOST-环境变量-修改监听地址" class="headerlink" title="（可选）设置 OLLAMA_HOST 环境变量 (修改监听地址)"></a>（可选）设置 OLLAMA_HOST 环境变量 (修改监听地址)</h4><p>如果你需要让局域网内的其他设备也能访问你的 Ollama 服务，可以配置 OLLAMA_HOST 环境变量。</p><ol><li>同样在 “<strong>环境变量</strong>” 窗口的 “<strong>系统变量(S)</strong>” 区域 (或者 “用户变量(U)” 区域)，点击 “<strong>新建(W)…</strong>” 按钮。</li><li>在 “<strong>变量名(N)</strong>” 输入框中，输入： <code>OLLAMA_HOST</code></li><li>在 “<strong>变量值(V)</strong>” 输入框中，输入 <code>0.0.0.0:11434</code>  (或者你想要指定的端口号，默认端口是 11434)。<ul><li><code>0.0.0.0</code> 表示监听所有网络接口，允许局域网访问。</li><li><code>11434</code> 是 Ollama 默认端口。</li><li><strong>示例：</strong>  <code>0.0.0.0:11434</code></li></ul></li><li>点击 “<strong>确定</strong>” 按钮，关闭 “<strong>新建系统变量</strong>” (或者 “新建用户变量”) 窗口。</li></ol><h4 id="步骤-3：重启-Ollama-或-PowerShell-使环境变量生效"><a href="#步骤-3：重启-Ollama-或-PowerShell-使环境变量生效" class="headerlink" title="步骤 3：重启 Ollama 或 PowerShell 使环境变量生效"></a>步骤 3：重启 Ollama 或 PowerShell 使环境变量生效</h4><p>环境变量设置完成后，你需要 <strong>重启 Ollama 服务</strong> 或者 <strong>重新启动你的 命令提示符 (CMD) 或 PowerShell 窗口</strong>，才能让新的环境变量生效。</p><ul><li><strong>重启 Ollama 服务</strong>: 如果你运行了 ollama serve，先 Ctrl + C 停止，再重新运行 ollama serve。</li><li><strong>重启命令提示符&#x2F;PowerShell</strong>: 关闭所有已打开的窗口，重新打开新的窗口。</li></ul><h4 id="步骤-4：验证环境变量是否生效"><a href="#步骤-4：验证环境变量是否生效" class="headerlink" title="步骤 4：验证环境变量是否生效"></a>步骤 4：验证环境变量是否生效</h4><ol><li>重新打开 命令提示符 (CMD) 或者 PowerShell。</li><li>验证 OLLAMA_MODELS: 输入以下命令并回车：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：E:\ollama\models (如果你设置的是 E:\ollama\models)</span></span><br><span class="line">echo %OLLAMA_MODELS%</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出 0.0.0.0:11434</span></span><br><span class="line">echo %OLLAMA_HOST%</span><br></pre></td></tr></table></figure><h3 id="运行-Ollama"><a href="#运行-Ollama" class="headerlink" title="运行 Ollama"></a>运行 Ollama</h3><ul><li>命令行语句启动</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ollama serve</span><br></pre></td></tr></table></figure><blockquote><p>启动 Ollama 时会报错如下，因为 Windows 系统安装 Ollama 时会默认开机启动，Ollama 服务默认是 <a href="http://127.0.0.1:11434/">http://127.0.0.1:11434</a><br><code>Error: listen tcp 127.0.0.1:11434: bind: Only one usage of each socket address (protocol/network address/port) is normally permitted.</code></p></blockquote><ul><li>解决方案</li></ul><ol><li>退出 Ollama<ul><li>在 Windows 任务管理器中结束 ollama.exe 任务</li><li>在 Windows 下方的导航栏找到 Ollama 图标右键并退出 Ollama</li></ul></li><li>启动 Ollama<ul><li>再次在 CMD 命令行中执行 <code>ollama serve</code> 命令来再次启动 Ollama</li><li>在 Windows 最近安装找打 Ollama 图标单机启动即可</li></ul></li></ol><h3 id="验证安装成功🎉"><a href="#验证安装成功🎉" class="headerlink" title="验证安装成功🎉"></a>验证安装成功🎉</h3><ul><li>终端输入</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ollama -h</span><br></pre></td></tr></table></figure><p>输出如下即表示安装成功🎉</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Large language model runner</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  ollama [flags]</span><br><span class="line">  ollama [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  serve       Start ollama</span><br><span class="line">  create      Create a model from a Modelfile</span><br><span class="line">  show        Show information for a model</span><br><span class="line">  run         Run a model</span><br><span class="line">  stop        Stop a running model</span><br><span class="line">  pull        Pull a model from a registry</span><br><span class="line">  push        Push a model to a registry</span><br><span class="line">  list        List models</span><br><span class="line">  ps          List running models</span><br><span class="line">  cp          Copy a model</span><br><span class="line">  rm          Remove a model</span><br><span class="line">  help        Help about any command</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help      help for ollama</span><br><span class="line">  -v, --version   Show version information</span><br><span class="line"></span><br><span class="line">Use &quot;ollama [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><h3 id="安装-DeepSeek-R1-模型"><a href="#安装-DeepSeek-R1-模型" class="headerlink" title="安装 DeepSeek-R1 模型"></a>安装 DeepSeek-R1 模型</h3><p>前往 <a href="https://ollama.com/library">Ollama 模型库</a> 搜索你 DeepSeek-R1 模型，然后直接启动。</p><pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ollama run deepseek-r1:7b</span><br></pre></td></tr></table></figure></code></pre><blockquote><p>下载模型的速度取决网络带宽，下载完成之后即可使用，使用 <code>Control-D</code> 退出聊天。</p></blockquote><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>安装 Docker 是为安装 Open-WebUI，如果你本地已经安装了 Docker 已经安装了 Docker 可以跳过本章节。</p><blockquote><p>在安装 Docker 过程中最好在机器上运行科学上网。</p></blockquote><ol><li><p>前往 <a href="https://www.docker.com/">Docker 官网</a>下载安装包</p><p> <img src="/2025/02/15/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%9F%BA%E4%BA%8EWindows%E6%90%AD%E5%BB%BAOllama-Docker-OpenWebUI-DeepSeek-R1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83/%E4%B8%8B%E8%BD%BDDocker.png" alt="下载Docker"></p></li><li><p>下载完成后双击安装 Docker 安装包，安装过程中最好勾选 Docker 官方推荐的选项，可以减少较多的配置操作。</p></li><li><p>验证安装<br> 打开 CMD 输入 <code>docker --version</code> 命令查看版本信息，如果能够正常输出版本信息即表示安装完成。</p></li></ol><h3 id="安装-Open-WebUI"><a href="#安装-Open-WebUI" class="headerlink" title="安装 Open-WebUI"></a>安装 Open-WebUI</h3><blockquote><p>需要科学上网环境，否则 docker 的镜像包拉取会失败</p></blockquote><p>Ollama 就在本地机器的话，可以执行如下命令安装并运行 Open-WebUI</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure><p>如果本地有 Nvidia 显卡的话，可以运行如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui-gpu --restart always ghcr.io/open-webui/open-webui:cuda</span><br></pre></td></tr></table></figure><p>当 docker 镜像拉取完毕并启动后，可以在浏览器中输入 <code>http://localhost:3000/</code> 来访问 Open-WebUI。</p><p>首次登陆 Open-WebUI，会提示新建用户，需要输入名称、邮箱和密码。邮箱可以随便写并不会进行验证邮箱有效性。</p><p><img src="/2025/02/15/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%9F%BA%E4%BA%8EWindows%E6%90%AD%E5%BB%BAOllama-Docker-OpenWebUI-DeepSeek-R1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83/OpenWebUI%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7.png" alt="OpenWebUI创建用户"></p><p>接下来就可以尽情的聊天了。</p><p><img src="/2025/02/15/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%9F%BA%E4%BA%8EWindows%E6%90%AD%E5%BB%BAOllama-Docker-OpenWebUI-DeepSeek-R1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%8E%AF%E5%A2%83/%E8%81%8A%E5%A4%A9.png" alt="聊天"></p><p>不仅可以在本机访问 Open-WebUI，本地局域网中的其他设备也能通过 <code>http://本机IP:3000/</code> Open-WebUI 进行访问 Ollama DeepSeek-R1 模型。</p><p><img src="/%E6%89%8B%E6%9C%BA%E4%B8%AD%E8%AE%BF%E9%97%AEOpenWebUI.png" alt="手机中访问OpenWebUI"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe width=&quot;760&quot; height=&quot;427&quot;
src=&quot;https://www.youtube.com/embed/fcquZpYdntQ&quot;frameborder=&quot;0&quot;
allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;本文主要介绍如何在 Wind</summary>
      
    
    
    
    
    <category term="大模型" scheme="https://zenvzenv.github.io/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="deepseek" scheme="https://zenvzenv.github.io/tags/deepseek/"/>
    
    <category term="ollama" scheme="https://zenvzenv.github.io/tags/ollama/"/>
    
  </entry>
  
  <entry>
    <title>【ComfyUI】ComfyUI从入门到精通1：ComfyUI安装部署及常用配置</title>
    <link href="https://zenvzenv.github.io/2025/02/08/%E3%80%90ComfyUI%E3%80%91ComfyUI%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A1%EF%BC%9AComfyUI%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://zenvzenv.github.io/2025/02/08/%E3%80%90ComfyUI%E3%80%91ComfyUI%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A1%EF%BC%9AComfyUI%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2025-02-08T06:00:56.000Z</published>
    <updated>2025-04-24T23:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍 ComfyUI 的本地(Windows系统)安装部署，ComfyUI 的一些目录作用介绍，以及一些常用插件的安装方法</p><h2 id="安装-ComfyUI"><a href="#安装-ComfyUI" class="headerlink" title="安装 ComfyUI"></a>安装 ComfyUI</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>首先需要去 <a href="https://github.com/comfyanonymous/ComfyUI/releases/">ComfyUI 的 GitHub 的发布页面</a> 下载 ComfyUI 的压缩包(ComfyUI_windows_portable_nvidia.7z)。可以选择历史版本下载或者下载最新发布版本，推荐下载最新的发布版本。</p><p>ComfyUI 官方只提供 Windows 系统 + Nvidia 显卡的二进制压缩包，如果你是 Linux 系统或者是 AMD 显卡的话，需要参照 <a href="https://github.com/comfyanonymous/ComfyUI?tab=readme-ov-file#installing">ComfyUI 的官方 readme 文档</a>安装。</p><h3 id="安装部署-ComfyUI"><a href="#安装部署-ComfyUI" class="headerlink" title="安装部署 ComfyUI"></a>安装部署 ComfyUI</h3><p>安装其实很简单，只需要解压 <code>ComfyUI_windows_portable_nvidia.7z</code> 压缩包即可。</p><p>解压完之后，目录结构如下所示：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ComfyUI/</span><br><span class="line">python_embeded/</span><br><span class="line">README_VERY_IMPORTANT.txt</span><br><span class="line">run_cpu.bat</span><br><span class="line">run_nvidia_gpu.bat</span><br><span class="line">update/</span><br></pre></td></tr></table></figure><ul><li><code>ComfyUI</code> 目录为 ComfyUI 的主程序，所有的 Checkpoint 模型、VAE 编码器、插件都在此文件夹中</li><li><code>python_embeded</code> 目录为 ComfyUI 内置 python 运行环境，确保程序一致性</li><li><code>run_cpu.bat</code> 脚本为无 nVidia 显卡的情况下运行 ComfyUI 的启动脚本</li><li><code>run_nvidia_gpu.bat</code> 为以 nVidia 显卡的情况运行 ComfyUI 的启动脚本</li><li><code>update</code> 目录为 ComfyUI 更新时需要用到的目录</li></ul><h2 id="启动-ComfyUI"><a href="#启动-ComfyUI" class="headerlink" title="启动 ComfyUI"></a>启动 ComfyUI</h2><p>如果你的电脑有 nVidia 显卡，那么可以双击 <code>run_nvidia_gpu.bat</code> 脚本启动 ，如果没有 nVidia 显卡则双击 <code>run_cpu.bat</code> 脚本启动。</p><p>第一次启动 ComfyUI 的时候，会有个默认的工作流，其中已经包含了最简单的完整流程，包含模型、提示词、采样器、编码器和图片保存。</p><p>此时，整个流程还不能运行起来，因为新安装的 ComfyUI 没有模型，需要先下载 <a href="https://huggingface.co/Comfy-Org/stable-diffusion-v1-5-archive/resolve/main/v1-5-pruned-emaonly-fp16.safetensors?download=true">v1-5-pruned-emaonly-fp16.safetensors</a> 模型，下载完之后将模型放到 <code>ComfyUI/models/checkpoints</code> 目录中即可。</p><p>准备就绪之后可以点击 <code>Queue</code> 进行图片生成。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>ComfyUI 安装插件的方式比较简单，将需要安装的插件放到 <code>ComfyUI\custom_nodes</code> 目录下即可。</p><p>安装 ComfyUI 插件的方式有多种方式：</p><ol><li>下载要安装插件的源码压缩包，将压缩包解压到 <code>ComfyUI/custom_nodes</code> 目录下即可</li><li>直接在 <code>ComfyUI/custom_nodes</code> 目录下 clone 要插件的源码，clone 完成之后插件也就安装完毕</li></ol><blockquote><p>我一般采用第2种方式进行安装。</p></blockquote><h3 id="ComfyUI-Manager-插件"><a href="#ComfyUI-Manager-插件" class="headerlink" title="ComfyUI-Manager 插件"></a>ComfyUI-Manager 插件</h3><p>ComfyUI-Manager 插件可以帮助我们管理 ComfyUI，可以简化安装&#x2F;更新插件、模型的过程，提高效率。</p><p>在 GitHub 上搜索 ComfyUI-Manager 项目，复制 ComfyUI-Manager 的 GitHub 的项目地址，在 <code>ComfyUI/custom_nodes</code> 目录下打开 gitbash，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ltdrdata/ComfyUI-Manager comfyui-manager</span><br></pre></td></tr></table></figure><p>clone 完之后重启 ComfyUI 完成安装，安装完之后右上角会有 <code>Manager</code> 按钮，里面可以管理 ComfyUI 的插件和模型。</p><h3 id="ComfyUI-Custom-Nodes-AlekPet-插件"><a href="#ComfyUI-Custom-Nodes-AlekPet-插件" class="headerlink" title="ComfyUI_Custom_Nodes_AlekPet 插件"></a>ComfyUI_Custom_Nodes_AlekPet 插件</h3><p>ComfyUI_Custom_Nodes_AlekPet 插件内置了很多实用的 ComfyUI 工作流节点，俗称小瑞士军刀。</p><p>通过 ComfyUI-Manager 来安装会更便捷简单。</p><ol><li>点击 <code>Manager</code> 按钮</li></ol><p><img src="/2025/02/08/%E3%80%90ComfyUI%E3%80%91ComfyUI%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A1%EF%BC%9AComfyUI%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/ComfyUI%E7%AE%A1%E7%90%86%E6%8C%89%E9%92%AE.png" alt="ComfyUI管理按钮.png"></p><ol start="2"><li>点击 <code>Custom Nodes Manager</code> 按钮</li></ol><p><img src="/2025/02/08/%E3%80%90ComfyUI%E3%80%91ComfyUI%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A1%EF%BC%9AComfyUI%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E6%8C%89%E9%92%AE.png" alt="插件管理按钮.png"></p><ol start="3"><li>搜索 ComfyUI_Custom_Nodes_AlekPet 插件并安装</li></ol><p><img src="/2025/02/08/%E3%80%90ComfyUI%E3%80%91ComfyUI%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A1%EF%BC%9AComfyUI%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/%E6%90%9C%E7%B4%A2%E5%B9%B6%E5%AE%89%E8%A3%85AlekPet%E6%8F%92%E4%BB%B6.png" alt="搜索并安装AlekPet插件.png"></p><p>安装完成后重启 ComfyUI 即可。</p><h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p>在 ComfyUI-Manager 中的 <code>Custom Nodes Manager</code> 里搜索 <code>AIGODLIKE-ComfyUI-Translation</code> 插件。</p><p><img src="/2025/02/08/%E3%80%90ComfyUI%E3%80%91ComfyUI%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A1%EF%BC%9AComfyUI%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/%E5%AE%89%E8%A3%85%E6%B1%89%E5%8C%96%E6%8F%92%E4%BB%B6.png" alt="安装汉化插件.png"></p><p>在 ComfyUI 的配置中找到相关配置，选择语言为中文即可。</p><p><img src="/2025/02/08/%E3%80%90ComfyUI%E3%80%91ComfyUI%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A1%EF%BC%9AComfyUI%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/%E6%B1%89%E5%8C%96ComfyUI%E7%95%8C%E9%9D%A2.png" alt="汉化ComfyUI界面.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文主要介绍 ComfyUI 的本地(Windows系统)安装部署，ComfyUI 的一些目录作用介绍，以及一些常用插件的安装方法&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="ComfyUI" scheme="https://zenvzenv.github.io/tags/ComfyUI/"/>
    
    <category term="AI" scheme="https://zenvzenv.github.io/tags/AI/"/>
    
    <category term="图片生成" scheme="https://zenvzenv.github.io/tags/%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>从 RPM 中反向提取 SPEC 文件</title>
    <link href="https://zenvzenv.github.io/2023/11/03/%E4%BB%8E-RPM-%E4%B8%AD%E5%8F%8D%E5%90%91%E6%8F%90%E5%8F%96-SPEC-%E6%96%87%E4%BB%B6/"/>
    <id>https://zenvzenv.github.io/2023/11/03/%E4%BB%8E-RPM-%E4%B8%AD%E5%8F%8D%E5%90%91%E6%8F%90%E5%8F%96-SPEC-%E6%96%87%E4%BB%B6/</id>
    <published>2023-11-03T01:41:08.000Z</published>
    <updated>2025-04-24T23:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍使用 <code>rpmrebuild</code> 工具来反向提取 spec 文件</p></blockquote><h2 id="安装-rpmrebuild-工具"><a href="#安装-rpmrebuild-工具" class="headerlink" title="安装 rpmrebuild 工具"></a>安装 <code>rpmrebuild</code> 工具</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release centos-release</span><br><span class="line">yum install -y rpm-build rpmrebuild rpm cpio</span><br></pre></td></tr></table></figure><h2 id="从-RPM-包中提取-SPEC-文件"><a href="#从-RPM-包中提取-SPEC-文件" class="headerlink" title="从 RPM 包中提取 SPEC 文件"></a>从 RPM 包中提取 SPEC 文件</h2><p>这里以 minio 为例</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpmrebuild --package --notest-install --spec-only=minio.spec minio-20231101183725.0.0.x86_64.rpm</span><br></pre></td></tr></table></figure><p>其中 <code>--spec-only</code> 是最终 <code>spec</code> 文件的名称</p><h2 id="附录：帮助手册"><a href="#附录：帮助手册" class="headerlink" title="附录：帮助手册"></a>附录：帮助手册</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> rpmrebuild --help</span><br><span class="line">rpmrebuild is a tool to rebuild an rpm file from the rpm database</span><br><span class="line">Usage: rpmrebuild [options] package</span><br><span class="line">options:</span><br><span class="line">   -5  --md5-compat-digest      use rpm 4.4 compatible digest (md5)</span><br><span class="line">   -a, --additional=&lt;flags&gt;     additional flags to be pass to the rpmbuild</span><br><span class="line">   -b, --batch                  batch mode (ask no questions)</span><br><span class="line">   -c, --comment-missing=&lt;y|n&gt;  comment missing files in the specfile. default : no.</span><br><span class="line">   -d, --directory=&lt;dir&gt;        specify the working directory</span><br><span class="line">   -D, --define=&lt;define&gt;        defines to be passed to the rpmbuild</span><br><span class="line">   -e, --edit-spec              alias for --edit-whole</span><br><span class="line">   -f, --filter=&lt;command&gt;       alias for --change-spec-whole</span><br><span class="line">   -i, --includes=&lt;file&gt;        read options from the file &lt;file&gt;</span><br><span class="line">   -I, --install                install the created rpm</span><br><span class="line">   -k, --keep-perm              alias for --pug-from-fs</span><br><span class="line">       --pug-from-fs            keep installed files permission, uid and gid</span><br><span class="line">       --pug-from-db (default)  use files permission, uid and gid from rpm db</span><br><span class="line">       --cap-from-fs            use files posix capabilities from installed files</span><br><span class="line">       --cap-from-db (default)  use files posix capabilities from rpm database</span><br><span class="line">   -l, --list-plugin            list installed plugins</span><br><span class="line">   -m, --modify=&lt;command&gt;       alias for --change-files</span><br><span class="line">   -n, --notest-install         do not perform a test install</span><br><span class="line">   -p, --package                use package file, not installed rpm</span><br><span class="line">   -P, --autoprovide            force rpm to auto generate &quot;Provide:&quot;</span><br><span class="line">   -r, --release=N              force release to N</span><br><span class="line">   -R, --autorequire            force rpm to auto generate &quot;Require:&quot;</span><br><span class="line">   -s, --spec-only=&lt;specfile&gt;   generate specfile only. (If &lt;specfile&gt; &quot;-&quot; stdout will be used)</span><br><span class="line">   -v, --verbose                verbose</span><br><span class="line">       --debug                  debug mode (do not remove temporary working files)</span><br><span class="line">   -V, --version                print rpmrebuild version</span><br><span class="line">   -w, --warning                print warning if detect filenames with globbing characters (default : no).</span><br><span class="line">   -y, --verify=&lt;y|n&gt;           verify package (rpm -V) before processing (default : yes).</span><br><span class="line">   -h, --help                   print this help</span><br><span class="line">       --help-plugins           print help about plugins options</span><br><span class="line"></span><br><span class="line">Copyright (C) 2002-2007 by Eric Gerbier (&lt;gerbier@users.sourceforge.net&gt;)</span><br><span class="line">this program is distributed under GNU General Public License</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要介绍使用 &lt;code&gt;rpmrebuild&lt;/code&gt; 工具来反向提取 spec 文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装-rpmrebuild-工具&quot;&gt;&lt;a href=&quot;#安装-rpmrebuild-工具&quot; cla</summary>
      
    
    
    
    
    <category term="RPM" scheme="https://zenvzenv.github.io/tags/RPM/"/>
    
    <category term="SPEC" scheme="https://zenvzenv.github.io/tags/SPEC/"/>
    
    <category term="反向提取" scheme="https://zenvzenv.github.io/tags/%E5%8F%8D%E5%90%91%E6%8F%90%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7(ARM64) 编译 Clickhouse 记录</title>
    <link href="https://zenvzenv.github.io/2023/05/10/CentOS7-ARM64-%E7%BC%96%E8%AF%91-Clickhouse-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zenvzenv.github.io/2023/05/10/CentOS7-ARM64-%E7%BC%96%E8%AF%91-Clickhouse-%E8%AE%B0%E5%BD%95/</id>
    <published>2023-05-10T16:00:00.000Z</published>
    <updated>2023-05-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 CentOS7 (3.10.0-693.el7.x86_64 GNU&#x2F;Linux)</p><p>本文基于 ClickHouse-v23.3.2.37-lts</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>需要 cmake 3.20 or newer</li><li>需要 clang 15.0 or newer</li><li>需要 lld 15 or newer</li><li>需要 Ninja</li><li>需要 Yasm</li><li>需要 Gawk</li><li>需要 arm 交叉编译环境</li></ul><h3 id="安装必要工具"><a href="#安装必要工具" class="headerlink" title="安装必要工具"></a>安装必要工具</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add extra repos</span></span><br><span class="line">yum -y install epel-release centos-release-scl centos-release-scl-rh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">installing needed libs</span></span><br><span class="line">yum -y install readline-devel unixODBC-devel openssl-devel libicu-devel libtool-ltdl-devel openssl-devel scl-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">installing build tools</span></span><br><span class="line">yum -y install git devtoolset-9 tar wget rh-python36</span><br><span class="line">yum -y install http://repo.okay.com.mx/centos/7/x86_64/release/okay-release-1-5.el7.noarch.rpm</span><br><span class="line">yum -y install ninja-build yasm gawk</span><br><span class="line">yum -y update binutils</span><br></pre></td></tr></table></figure><h2 id="安装-cmake"><a href="#安装-cmake" class="headerlink" title="安装 cmake"></a>安装 cmake</h2><p>安装步骤如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https://github.com/Kitware/CMake/releases/download/v3.26.3/cmake-3.26.3-linux-x86_64.tar.gz</span><br><span class="line">tar xzf cmake-3.26.3-linux-x86_64.tar.gz</span><br><span class="line">ln -svf /opt/cmake-3.26.3-linux-x86_64/bin/* /usr/bin/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本，验证是否安装成功</span></span><br><span class="line">cmake --version</span><br></pre></td></tr></table></figure><h2 id="安装-clang-与-lld"><a href="#安装-clang-与-lld" class="headerlink" title="安装 clang 与 lld"></a>安装 clang 与 lld</h2><p>先下载好安装包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你想要安装的目录</span></span><br><span class="line">export basedir=/opt</span><br><span class="line"></span><br><span class="line">cd &quot;$basedir&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此部分最好科学上网，否则速度感人</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config --global http.proxy socks5://127.0.0.1:7890</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config --global https.proxy socks5://127.0.0.1:7890</span></span><br><span class="line">git clone https://github.com/llvm/llvm-project.git</span><br><span class="line">git tag</span><br><span class="line">git checkout -b remotes/origin/release/16.x</span><br><span class="line">git checkout llvmorg-16.0.3</span><br></pre></td></tr></table></figure><p>执行编译安装 clang 与 lld 步骤</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export basedir=/opt</span><br><span class="line">cd &quot;$basedir&quot;</span><br><span class="line"></span><br><span class="line">export THREADS=$(grep -c ^processor /proc/cpuinfo)</span><br><span class="line">mkdir $basedir/clang-build-16.0.3 &amp;&amp; cd $basedir/clang-build-16.0.3</span><br><span class="line">scl enable devtoolset-9 rh-python36 &#x27;cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang;lld&quot; -G Ninja ../llvm-project/llvm&#x27;</span><br><span class="line">ninja -j $THREADS &amp;&amp; ninja install</span><br></pre></td></tr></table></figure><p>此过程会耗费大量时间，请耐心等待。</p><h2 id="编译-Clickhouse"><a href="#编译-Clickhouse" class="headerlink" title="编译 Clickhouse"></a>编译 Clickhouse</h2><p>下载 ClickHouse 源码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">git clone https://github.com/ClickHouse/ClickHouse.git</span><br></pre></td></tr></table></figure><p>安装交叉编译环，前往 <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">arm developer 官网</a> 下载交叉编译的环境。下载名为 <code>x86_64 Linux hosted cross toolchains</code> 的资源包。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https://developer.arm.com/-/media/Files/downloads/gnu/12.2.rel1/binrel/arm-gnu-toolchain-12.2.rel1-x86_64-aarch64-none-linux-gnu.tar.xz?rev=6750d007ffbf4134b30ea58ea5bf5223&amp;hash=0F1CE8273B8A30129CA04BD61FFB547D</span><br><span class="line">mkdir -p /opt/ClickHouse/build-aarch64/cmake/toolchain/linux-aarch64</span><br><span class="line">tar xJf arm-gnu-toolchain-12.2.rel1-x86_64-aarch64-none-linux-gnu.tar.xz -C /opt/ClickHouse/build-aarch64/cmake/toolchain/linux-aarch64/ --strip-components=1</span><br></pre></td></tr></table></figure><p>开始编译操作</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export codedir=/opt/ClickHouse</span><br><span class="line">cd $codedir</span><br><span class="line">git tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">好像切换了分支没生效，编译的版本为23.3.2.1</span></span><br><span class="line">git checkout -b v23.3.2.37-lts</span><br><span class="line">git submodule sync</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此部分最好科学上网，否则速度感人</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config --global http.proxy socks5://127.0.0.1:7890</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config --global https.proxy socks5://127.0.0.1:7890</span></span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line">mkdir build-arm64</span><br><span class="line"></span><br><span class="line">scl enable devtoolset-9 rh-python36 &#x27;CC=/usr/local/bin/clang CXX=/usr/local/bin/clang++ cmake . -Bbuild-arm64 -DCOMPILER_CACHE=disabled -DCMAKE_MAKE_PROGRAM:FILEPATH=/usr/bin/ninja -DCMAKE_TOOLCHAIN_FILE=cmake/linux/toolchain-aarch64.cmake&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">THREADS根据CPU个数自行进行设置</span></span><br><span class="line">export THREADS=$(grep -c ^processor /proc/cpuinfo)</span><br><span class="line">ninja -j $THREADS clickhouse -C build-arm64</span><br></pre></td></tr></table></figure><p>其中 CC 为 clang 的安装目录，CXX 为 clang++ 的安装目录，需要根据自己的实际情况进行替换。</p><p>此过程需要较长时间，请耐心等待。</p><p>编译完毕之后，可执行文件将会生成 <code>/opt/ClickHouse/build-arm64/programs/clickhouse</code> 可执行的二进制文件。可以执行如下命令来查看</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./clickhouse</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Use one of the following commands:</span><br><span class="line">clickhouse local [args]</span><br><span class="line">clickhouse client [args]</span><br><span class="line">clickhouse benchmark [args]</span><br><span class="line">clickhouse server [args]</span><br><span class="line">clickhouse extract-from-config [args]</span><br><span class="line">clickhouse compressor [args]</span><br><span class="line">clickhouse format [args]</span><br><span class="line">clickhouse copier [args]</span><br><span class="line">clickhouse obfuscator [args]</span><br><span class="line">clickhouse git-import [args]</span><br><span class="line">clickhouse keeper [args]</span><br><span class="line">clickhouse keeper-converter [args]</span><br><span class="line">clickhouse install [args]</span><br><span class="line">clickhouse start [args]</span><br><span class="line">clickhouse stop [args]</span><br><span class="line">clickhouse status [args]</span><br><span class="line">clickhouse restart [args]</span><br><span class="line">clickhouse static-files-disk-uploader [args]</span><br><span class="line">clickhouse su [args]</span><br><span class="line">clickhouse hash-binary [args]</span><br><span class="line">clickhouse disks [args]</span><br></pre></td></tr></table></figure><h3 id="启动-server"><a href="#启动-server" class="headerlink" title="启动 server"></a>启动 server</h3><p>使用 <code>./clickhouse server</code> 来启动服务</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Processing configuration file &#x27;config.xml&#x27;.</span><br><span class="line">There is no file &#x27;config.xml&#x27;, will use embedded config.</span><br><span class="line">2023.05.10 15:30:34.434959 [ 4253 ] &#123;&#125; &lt;Information&gt; SentryWriter: Sending crash reports is disabled</span><br><span class="line">2023.05.10 15:30:34.446996 [ 4253 ] &#123;&#125; &lt;Trace&gt; Pipe: Pipe capacity is 1.00 MiB</span><br><span class="line">2023.05.10 15:30:34.813067 [ 4253 ] &#123;&#125; &lt;Information&gt; Application: Starting ClickHouse 23.3.2.1 (revision: 54472, git hash: 1b144bcd101ddf23466ba67e4fa0fd27afb9c060, build id: &lt;unknown&gt;), PID 4253</span><br><span class="line">2023.05.10 15:30:34.813124 [ 4253 ] &#123;&#125; &lt;Information&gt; Application: starting up</span><br></pre></td></tr></table></figure><h3 id="启动-client"><a href="#启动-client" class="headerlink" title="启动 client"></a>启动 client</h3><p>使用 <code>./clickhouse client</code> 来连接 server</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ClickHouse client version 23.3.2.1.</span><br><span class="line">Connecting to localhost:9000 as user default.</span><br><span class="line">Connected to ClickHouse server version 23.3.2 revision 54462.</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line"> * Linux transparent hugepages are set to &quot;always&quot;. Check /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"></span><br><span class="line">localhost :)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文基于 CentOS7 (3.10.0-693.el7.x86_64 GNU&amp;#x2F;Linux)&lt;/p&gt;
&lt;p&gt;本文基于 ClickHouse-v23.3.2.37-lts&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="记录" scheme="https://zenvzenv.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Clickhouse" scheme="https://zenvzenv.github.io/tags/Clickhouse/"/>
    
    <category term="编译" scheme="https://zenvzenv.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
    <category term="x86_arm_corss" scheme="https://zenvzenv.github.io/tags/x86-arm-corss/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7(X86_64) 编译 ClickHouse 记录</title>
    <link href="https://zenvzenv.github.io/2023/05/04/CentOS7-X86-64-%E7%BC%96%E8%AF%91-ClickHouse-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zenvzenv.github.io/2023/05/04/CentOS7-X86-64-%E7%BC%96%E8%AF%91-ClickHouse-%E8%AE%B0%E5%BD%95/</id>
    <published>2023-05-04T07:56:55.000Z</published>
    <updated>2023-05-10T07:56:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 CentOS7 (3.10.0-693.el7.x86_64 GNU&#x2F;Linux)</p><p>本文基于 ClickHouse-v23.3.2.37-lts</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>需要 cmake 3.20 or newer</li><li>需要 clang 15.0 or newer</li><li>需要 lld 15 or newer</li><li>需要 Ninja</li><li>需要 Yasm</li><li>需要 Gawk</li></ul><h3 id="安装必要工具"><a href="#安装必要工具" class="headerlink" title="安装必要工具"></a>安装必要工具</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add extra repos</span></span><br><span class="line">yum -y install epel-release centos-release-scl centos-release-scl-rh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">installing needed libs</span></span><br><span class="line">yum -y install readline-devel unixODBC-devel openssl-devel libicu-devel libtool-ltdl-devel openssl-devel scl-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">installing build tools</span></span><br><span class="line">yum -y install git devtoolset-9 tar wget rh-python36</span><br><span class="line">yum -y install http://repo.okay.com.mx/centos/7/x86_64/release/okay-release-1-5.el7.noarch.rpm</span><br><span class="line">yum -y install ninja-build yasm gawk</span><br><span class="line">yum -y update binutils</span><br></pre></td></tr></table></figure><h3 id="安装-cmake"><a href="#安装-cmake" class="headerlink" title="安装 cmake"></a>安装 cmake</h3><p>安装步骤如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https://github.com/Kitware/CMake/releases/download/v3.26.3/cmake-3.26.3-linux-x86_64.tar.gz</span><br><span class="line">tar xzf cmake-3.26.3-linux-x86_64.tar.gz</span><br><span class="line">ln -svf /opt/cmake-3.26.3-linux-x86_64/bin/* /usr/bin/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本，验证是否安装成功</span></span><br><span class="line">cmake --version</span><br></pre></td></tr></table></figure><h3 id="安装-clang-与-lld"><a href="#安装-clang-与-lld" class="headerlink" title="安装 clang 与 lld"></a>安装 clang 与 lld</h3><p>先下载好安装包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你想要安装的目录</span></span><br><span class="line">export basedir=/opt</span><br><span class="line"></span><br><span class="line">cd &quot;$basedir&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此部分最好科学上网，否则速度感人</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config --global http.proxy socks5://127.0.0.1:7890</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config --global https.proxy socks5://127.0.0.1:7890</span></span><br><span class="line">git clone https://github.com/llvm/llvm-project.git</span><br><span class="line">git tag</span><br><span class="line">git checkout -b remotes/origin/release/16.x</span><br><span class="line">git checkout llvmorg-16.0.3</span><br></pre></td></tr></table></figure><p>执行编译安装 clang 与 lld 步骤</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export basedir=/opt</span><br><span class="line">cd &quot;$basedir&quot;</span><br><span class="line"></span><br><span class="line">export THREADS=$(grep -c ^processor /proc/cpuinfo)</span><br><span class="line">mkdir $basedir/llvm-16.0.3 &amp;&amp; cd $basedir/llvm-16.0.3</span><br><span class="line">scl enable devtoolset-9 rh-python36 &#x27;cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang;lld&quot; -G &quot;Unix Makefiles&quot; ../llvm-project/llvm&#x27;</span><br><span class="line">scl enable devtoolset-9 rh-python36 &#x27;make -j $THREADS &amp;&amp; make install&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>注意：lld 并不是必须编译的，如果本地系统的 <code>ld</code> 版本过低，可能需要使用 llvm 的 <code>lld</code> 来代替系统的 <code>ld</code> 以免编译时出现找不到相关库的问题</p></blockquote><p>也可以使用 <code>ninja</code> 来进行编译，速度会比 <code>make</code> 要快。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export basedir=/opt</span><br><span class="line">cd &quot;$basedir&quot;</span><br><span class="line"></span><br><span class="line">export THREADS=$(grep -c ^processor /proc/cpuinfo)</span><br><span class="line">mkdir $basedir/llvm-16.0.3 &amp;&amp; cd $basedir/llvm-16.0.3</span><br><span class="line">scl enable devtoolset-9 rh-python36 &#x27;cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang;lld&quot; -G Ninja ../llvm-project/llvm&#x27;</span><br><span class="line">scl enable devtoolset-9 rh-python36 &#x27;ninja -j $THREADS &amp;&amp; ninja install&#x27;</span><br></pre></td></tr></table></figure><p>此过程会耗费大量时间，请耐心等待。</p><h2 id="编译-Clickhouse"><a href="#编译-Clickhouse" class="headerlink" title="编译 Clickhouse"></a>编译 Clickhouse</h2><p>下载 ClickHouse 源码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">git clone https://github.com/ClickHouse/ClickHouse.git</span><br></pre></td></tr></table></figure><p>开始编译操作</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export codedir=/opt/ClickHouse</span><br><span class="line">git tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">好像切换了分支没生效，编译的版本为23.3.2.1</span></span><br><span class="line">git checkout -b v23.3.2.37-lts</span><br><span class="line">git submodule sync</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此部分最好科学上网，否则速度感人</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config --global http.proxy socks5://127.0.0.1:7890</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config --global https.proxy socks5://127.0.0.1:7890</span></span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line">mkdir -p $&#123;codedir&#125;/build</span><br><span class="line">cd $&#123;codedir&#125;/build</span><br><span class="line"></span><br><span class="line">scl enable devtoolset-9 rh-python36 &#x27;CC=/usr/local/bin/clang CXX=/usr/local/bin/clang++ cmake -DCMAKE_BUILD_TYPE:STRING=Release -DCOMPILER_CACHE=disabled -DCMAKE_MAKE_PROGRAM:FILEPATH=/usr/bin/ninja ..&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">THREADS根据CPU个数自行进行设置</span></span><br><span class="line">export THREADS=$(grep -c ^processor /proc/cpuinfo)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 clickhouse</span></span><br><span class="line">ninja -j $THREADS clickhouse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 odbc 桥接</span></span><br><span class="line">ninja -j $THREADS clickhouse-odbc-bridge</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 lib 桥接</span></span><br><span class="line">ninja -j $THREADS clickhouse-library-bridge</span><br></pre></td></tr></table></figure><p>其中 CC 为 clang 的安装目录，CXX 为 clang++ 的安装目录，需要根据自己的实际情况进行替换。</p><p>编译完毕之后，可执行文件在 <code>/opt/ClickHouse/build/programs</code> 下，可执行文件为 <code>clickhouse</code>。可以执行如下命令来查看</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./clickhouse</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Use one of the following commands:</span><br><span class="line">clickhouse local [args]</span><br><span class="line">clickhouse client [args]</span><br><span class="line">clickhouse benchmark [args]</span><br><span class="line">clickhouse server [args]</span><br><span class="line">clickhouse extract-from-config [args]</span><br><span class="line">clickhouse compressor [args]</span><br><span class="line">clickhouse format [args]</span><br><span class="line">clickhouse copier [args]</span><br><span class="line">clickhouse obfuscator [args]</span><br><span class="line">clickhouse git-import [args]</span><br><span class="line">clickhouse keeper [args]</span><br><span class="line">clickhouse keeper-converter [args]</span><br><span class="line">clickhouse install [args]</span><br><span class="line">clickhouse start [args]</span><br><span class="line">clickhouse stop [args]</span><br><span class="line">clickhouse status [args]</span><br><span class="line">clickhouse restart [args]</span><br><span class="line">clickhouse static-files-disk-uploader [args]</span><br><span class="line">clickhouse su [args]</span><br><span class="line">clickhouse hash-binary [args]</span><br><span class="line">clickhouse disks [args]</span><br></pre></td></tr></table></figure><h3 id="启动-server"><a href="#启动-server" class="headerlink" title="启动 server"></a>启动 server</h3><p>使用 <code>./clickhouse server</code> 来启动服务</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Processing configuration file &#x27;config.xml&#x27;.</span><br><span class="line">There is no file &#x27;config.xml&#x27;, will use embedded config.</span><br><span class="line">2023.05.10 15:30:34.434959 [ 4253 ] &#123;&#125; &lt;Information&gt; SentryWriter: Sending crash reports is disabled</span><br><span class="line">2023.05.10 15:30:34.446996 [ 4253 ] &#123;&#125; &lt;Trace&gt; Pipe: Pipe capacity is 1.00 MiB</span><br><span class="line">2023.05.10 15:30:34.813067 [ 4253 ] &#123;&#125; &lt;Information&gt; Application: Starting ClickHouse 23.3.2.1 (revision: 54472, git hash: 1b144bcd101ddf23466ba67e4fa0fd27afb9c060, build id: &lt;unknown&gt;), PID 4253</span><br><span class="line">2023.05.10 15:30:34.813124 [ 4253 ] &#123;&#125; &lt;Information&gt; Application: starting up</span><br></pre></td></tr></table></figure><h3 id="启动-client"><a href="#启动-client" class="headerlink" title="启动 client"></a>启动 client</h3><p>使用 <code>./clickhouse client</code> 来连接 server</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ClickHouse client version 23.3.2.1.</span><br><span class="line">Connecting to localhost:9000 as user default.</span><br><span class="line">Connected to ClickHouse server version 23.3.2 revision 54462.</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line"> * Linux transparent hugepages are set to &quot;always&quot;. Check /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"></span><br><span class="line">localhost :)</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h2 id="ld-cannot-find-lxxx"><a href="#ld-cannot-find-lxxx" class="headerlink" title="ld: cannot find -lxxx"></a>ld: cannot find -lxxx</h2><p>缺少编译时库的问题</p><p>本次编译解决方案为重新编译 LLVM 的 lld 项目来替代系统原有的 ld。具体编译与安装参见 <a href="https://lld.llvm.org/">这里</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文基于 CentOS7 (3.10.0-693.el7.x86_64 GNU&amp;#x2F;Linux)&lt;/p&gt;
&lt;p&gt;本文基于 ClickHouse-v23.3.2.37-lts&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="记录" scheme="https://zenvzenv.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Clickhouse" scheme="https://zenvzenv.github.io/tags/Clickhouse/"/>
    
    <category term="编译" scheme="https://zenvzenv.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>浅谈流水线(pipleline)模式</title>
    <link href="https://zenvzenv.github.io/2023/04/20/%E6%B5%85%E8%B0%88%E6%B5%81%E6%B0%B4%E7%BA%BF-pipleline-%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zenvzenv.github.io/2023/04/20/%E6%B5%85%E8%B0%88%E6%B5%81%E6%B0%B4%E7%BA%BF-pipleline-%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-04-20T11:19:12.000Z</published>
    <updated>2023-04-28T11:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 Java</p><p>本文基于 <a href="https://github.com/zenvzenv/slot">slot</a></p></blockquote><p>流水线模式是我个人最喜欢的设计模式，它可以帮我把复杂问题简单化，让复杂的流程变得更清晰易懂。</p><p>在诸多的优秀的开源项目中都能看到它的身影(如：Netty,Kafka)，我觉得这个模式还是值得学习下的。</p><p>网上的 <code>Pipeline</code> 实现各异，这篇文章也只是我个人的一个实现思路，为各位读者抛砖引玉，拓展思路。</p><h2 id="基本概念与实现"><a href="#基本概念与实现" class="headerlink" title="基本概念与实现"></a>基本概念与实现</h2><p>Pipeline 有三个基本的概念，分别是：Pipeline,Valve,Context，他们的关系大致如下所示：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-------------------------------------------------------------------------------+</span><br><span class="line">|   Pipeline                                                                    |</span><br><span class="line">|    +-----------+     +-----------+      +-----------+        +-----------+    |</span><br><span class="line">|    |           |     |           |      |           |        |           |    |</span><br><span class="line">|    |   Valve1  +----^+   Valve2  +-----^+   Valve3  +--------&gt;   Valve4  |    |</span><br><span class="line">|    |           |     |           |      |           |        |           |    |</span><br><span class="line">|    +-----------+     +-----------+      +-----------+        +-----------+    |</span><br><span class="line">|                                  Context                                      |</span><br><span class="line">+-------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>一条Pipeline有一个Context，多个Valve。这些Valve是很小的、单元化的，一个Valve只做一件简单的事。前后Valve之间的通信由Context来承载。但 Context 并不是必须的，如果你的需求足够简单的话，那么可以去除 Context。</p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>以我的理解，Pipeline 是存放 Valve 的容器，其实现为单向链表或双向链表，Pipeline 驱动整个业务流程的运行，什么时候终止、什么时候添加新 Valve 由 Pipeline 说了算。</p><p>一般来说，Pipeline 作为一个 <code>interface</code> 存在的，其中定义了一些 Pipeline 的通用行为，具体的实现由各个业务逻辑去实现。一个典型的 Pipeline 接口声明如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pipeline</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(PipelineConfig config)</span>;</span><br><span class="line">    <span class="comment">// 启动 Pipeline</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取 Pipeline 上下文</span></span><br><span class="line">    Context <span class="title function_">getContext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在 <a href="https://github.com/zenvzenv/slot">slot</a> 做了魔改，<a href="https://github.com/zenvzenv/slot">slot</a> 的 <a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/pipeline/Pipeline.java">Pipeline</a> 实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pipeline</span>&lt;I&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 管道名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 管道中第一个处理节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Valve&lt;I, ?&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 管道中最后一个处理节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Valve&lt;?, ?&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PipelineContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipelineContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pipeline</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在管道的最后添加一个处理节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> valve 处理节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(Valve&lt;?, ?&gt; valve)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Valve&lt;?, ?&gt; t = <span class="built_in">this</span>.tail;</span><br><span class="line">        tail = valve;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == t) &#123;</span><br><span class="line">            first = (Valve&lt;I, ?&gt;) valve;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t.setNext(valve);</span><br><span class="line">            valve.setPrev(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没实现，发现没有用到😅</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">linkAfter</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒第一个 Valve</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(I input)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first.bootstrap(input, <span class="built_in">this</span>.context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个业务流程的 Valve 被当作双向链表管理起来，有序的从第一个 Valve 节点开始被执行到最后一个 Valve。</p><p>在 <a href="https://github.com/zenvzenv/slot">slot</a> 中 分别有 <a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/pipeline/valve/InitValve.java">InitValve</a>,<a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/pipeline/valve/BuildSlotClassValve.java">BuildSlotClassValve</a>,<a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/pipeline/valve/InstrumentationValve.java">InstrumentationValve</a> 和 <a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/pipeline/valve/TransformClassValve.java">TransformClassValve</a>。</p><p>执行关系为 InitValve -&gt; BuildSlotClassValve -&gt; TransformClassValve -&gt; InstrumentationValve，具体到代码层面 <a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/SlotAgentBootstrap.java">SlotAgentBootstrap</a> 如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String slotConfFilePath, Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Properties</span> <span class="variable">init</span> <span class="operator">=</span> init(slotConfFilePath);</span><br><span class="line">    AnsiLog.info(<span class="string">&quot;开始埋点...,埋点配置文件为 : &#123;&#125;&quot;</span>, slotConfFilePath);</span><br><span class="line">    <span class="keyword">final</span> Pipeline&lt;Properties&gt; pipeline = <span class="keyword">new</span> <span class="title class_">Pipeline</span>&lt;&gt;(<span class="string">&quot;slot&quot;</span>);</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">InitValve</span>());</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">BuildSlotClassValve</span>());</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">TransformClassValve</span>());</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">InstrumentationValve</span>(inst));</span><br><span class="line"></span><br><span class="line">    pipeline.start(init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由链表组织所有的 Valve 是非常灵活的，我们可以在复杂的业务系统中动态的组装 Pipeline，实现复杂的业务逻辑。<a href="https://github.com/zenvzenv/slot">slot</a> 的业务相对稳定，变化相对较小，所以直接在代码里写死，显式调用。</p><p>我们也可以引入外部系统配置化，可以通过 json，xml 或数据库中的信息来描述各个 Valve 的依赖关系(当然这些 Valve 都是事先被实现好的)，类似 Tomcat 的 Pipeline 一样，json 大致如下所示：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;scene_a&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;valves&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;checkOrder&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;checkPayment&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;checkDiscount&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;computeMount&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;payment&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;DeductInventory&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;sendEmail&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;supportAlipay&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Valve"><a href="#Valve" class="headerlink" title="Valve"></a>Valve</h3><p>Valve 是 Pipeline 中最小的处理单元，所有的业务逻辑都将在 Valve 中被实现。<a href="https://github.com/zenvzenv/slot">slot</a> 的 <a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/pipeline/Valve.java">Valve</a> 实现如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Valve</span>&lt;I, O&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 流水线上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(PipelineContext context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理业务逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input   输入的数据类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 管道上线文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    O <span class="title function_">process</span><span class="params">(I input, PipelineContext context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个处理节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Valve&lt;?, ?&gt; getNext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置下一个处理节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 下一个处理节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Valve&lt;?, ?&gt; next)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置上一个处理节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prev 上一个梳理节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPrev</span><span class="params">(Valve&lt;?, ?&gt; prev)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个处理节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 处理节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Valve&lt;?, ?&gt; getPrev();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唤起执行节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input   输出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 流水线上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bootstrap</span><span class="params">(I input, PipelineContext context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，一个 Valve 有输入和输出，例如：BValve 依赖 AValve，那么 AValve 的输出就是 BValve 的输入，这样就可以将整个业务流程给串联起来。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>存放了整个 Pipeline 的必要的运行信息，类似于缓存一样的存在，Pipeline 中的任何 Valve 都可以向其中存放和读取数据。Context 没有特定的实现方式，可以按照自己的喜好去实现。在 <a href="https://github.com/zenvzenv/slot">slot</a> 中 <a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/pipeline/PipelineContext.java">PipelineContext</a> 使用 <code>LRU</code> 来实现，具体如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineContext</span> &#123;</span><br><span class="line">    <span class="comment">// LRU</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; CACHE = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">0.75F</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">cache</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        CACHE.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">getByKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CACHE.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>我们在某个Valve，可能会需要根据不同的业务线，有不同的逻辑。比如同一个文本，有些是发邮件，有些是发短信，有些是发钉钉。那这个时候就可以在配置里面写上当前这个业务线要发送的渠道，然后在Valve里面通过策略模式去决定使用什么渠道发送，这样就不用在Valve里面写死很多if-else，以后很好扩展。</p><h3 id="并行执行、"><a href="#并行执行、" class="headerlink" title="并行执行、"></a>并行执行、</h3><p>我们在前面看到Valve都是链式一个一个执行的。但有时候可能多个Valve彼此之间并不依赖，可以同时并行地去跑。比如发消息，可能多个Valve并行地去发。</p><p>这个时候我们可以把Pipeline改造一下，就像Jenkins设计Pipeline那样，把一个完整的Pipeline分成Phase、Stage、Step等，我们可以对某个Phase或者某个Step设置成可以并行执行的。这需要另外写一个并行执行的Pipeline，用CountDownLatch等工具来等待所有Valve执行完，往下走。</p><h3 id="使用-ThreadLocal"><a href="#使用-ThreadLocal" class="headerlink" title="使用 ThreadLocal"></a>使用 ThreadLocal</h3><p>理论上来说，我们在任何地方，都应该使用Context来在整个Pipeline中传递数据。但Context有时候使用起来相对比较麻烦。比如我们在Valve内部抽私有方法的时候，可能要经常把Context作为方法参数传进去，用起来并不是特别方便。而Valve应该是无状态的，不适合把Context放在Valve里面作为属性。</p><p>这个时候我们可以借助ThreadLocal来代替Context的作用，Valve通过使用ThreadLocal来存取数据。但使用ThreadLocal有三个需要注意的点。</p><p>如果你的Pipeline是要支持并行的，在并行Valve里面就不适合使用ThreadLocal。</p><p>使用ThreadLocal要记得在最后阶段Clear，避免影响当前线程下次执行Pipeline。</p><p>不要把零散的一个个属性放进ThreadLocal，因为同一种类型，一个线程只能在一个ThreadLocal里面放一个值。而我们的上下文可能会有多个String、boolean等值。如果使用ThreadLocal，可以把所有属性都包成一个Context类，放进ThreadLocal。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>虽然我们说一个Valve只做一件简单的事。但这是相对于整个流程来说的。有时候太过细化也不好，不方便管理。正确的做法应该是做好抽象和分组。比如我们会有一个“校验”阶段，就不用把具体每个字段的校验都单独抽成Valve放进主流程。我们可以就在主流程放一个“校验”的Valve，然后在这个“校验”的Valve里面专门生成一条“校验Pipeline”。这样主流程也比较清晰明了，每个Valve的职责也比较清晰。</p><blockquote><p>注意，子Pipeline应该有它单独的Context，但是它同时也应该具有主Pipeline的Context，是不是应该通过继承来实现?</p></blockquote><h3 id="工厂方法模板"><a href="#工厂方法模板" class="headerlink" title="工厂方法模板"></a>工厂方法模板</h3><p>Pipeline的优势在于通过配置化来灵活地实现不同的业务走不同的流程。实现统一化和差异化的完美结合。我们通过读取配置，生成一条Pipeline的时候，用工厂模式来实现比较好。<br>先读取当前的业务线，然后通过这个业务线和配置，完成整条Pipeline的实例化和装配，可以通过调用一个Pipeline Factory来实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> PipelineFactory.create(pipelineConfig);</span><br><span class="line">pipeline.start();</span><br></pre></td></tr></table></figure><h3 id="树与图"><a href="#树与图" class="headerlink" title="树与图"></a>树与图</h3><p>上面我们介绍的Pipeline，本质上是一个链。但如果往更通用（同时也更复杂）的方向去设计，它还可以做成一个图或者树。</p><p>假设我们在某个环节有一个条件分支，通过当时的context里面的数据状态，来判断下一步要走哪个Valve，形成一个树。最后可能又归拢到一个Valve，那就形成了一个图。</p><p>树和图会显著增加Pipeline的复杂度，需要配合上可视化配置，才能发挥出它的威力，但成本相对较高，除非真的业务非常多且复杂，不然不是很推荐。</p><p>树和图的Pipeline也需要结合数据结构专门设计Pipeline，节点如何往下走。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>Pipeline设计模式很强大，但它也有很明显的缺点。</p><ul><li><p>第一个缺点是可读性不强。因为它是可配置化的，且配置经常在外部（比如数据库里的一个JSON）。所以可读性不好。尤其是我们在读 Valve 代码的时候，「<strong>如果不对照配置，其实是不知道它的前后调用关系的</strong>」。</p></li><li><p>第二个缺点是Pipeline之间传递数据是通过Context，而不是简单的函数调用。所以一条Pipeline是有状态的，而且「<strong>方法调用内部修改Context</strong>」，而不是通过返回值，是有副作用的。</p></li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>Pipeline的本质是「<strong>数据结构和设计模式的灵活应用</strong>」，来应对流程复杂多变的业务场景。它并不是一个新的东西，也不是一个固定的设计模式，而应该是一种灵活的设计思想。</p><p>当然了，它也不是银弹，不能解决所有问题。还是要「<strong>合适</strong>」才行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文基于 Java&lt;/p&gt;
&lt;p&gt;本文基于 &lt;a href=&quot;https://github.com/zenvzenv/slot&quot;&gt;slot&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;流水线模式是我个人最喜欢的设计模式，它可以帮我把复杂问题简</summary>
      
    
    
    
    
    <category term="设计模式" scheme="https://zenvzenv.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="pipeline" scheme="https://zenvzenv.github.io/tags/pipeline/"/>
    
  </entry>
  
  <entry>
    <title>WiFi密码破解教程</title>
    <link href="https://zenvzenv.github.io/2023/04/11/WiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/"/>
    <id>https://zenvzenv.github.io/2023/04/11/WiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/</id>
    <published>2023-04-11T03:15:31.000Z</published>
    <updated>2023-04-11T03:15:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 Oracle VirtualBox</p><p>本文基于 kali-linux-2022.4-virtualbox-amd64</p><p>本文基于 RT3572(同时支持 2.4GHz 和 5GHz) 无线网卡</p><p>本文基于 Aircrack-ng 1.7</p></blockquote><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="虚拟机-VirtualBox"><a href="#虚拟机-VirtualBox" class="headerlink" title="虚拟机 VirtualBox"></a>虚拟机 VirtualBox</h3><p>虚拟机的安装和 Kali-Linux 的安装不再赘述，读者可自行搜索安装教程。</p><h3 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali-Linux"></a>Kali-Linux</h3><p><img src="https://www.kali.org/images/kali-dragon-icon.svg" alt="kali-dragon-icon"></p><blockquote><p>我们不建议将 Kali-Linux 作为你的主力操作系统。俗话说的好： Kali 用的好，牢饭吃到饱😈</p></blockquote><p>Kali-Linux 是基于 Debain 的 Linux 发行版，其内部预先安装了众多的安全审计工具，戳<a href="https://www.kali.org/docs/introduction/what-is-kali-linux/">这里</a>了解更多。</p><p>我们可以前去 <a href="https://www.kali.org/get-kali/">Kali-Linux</a> 下载系统镜像或者虚拟机安装包。我们一般推荐 <code>Installer Images</code> 和 <code>Virtual Machines</code> 这两个版本，当然你也可以根据自己的需要下载对应的版本。</p><h3 id="无线网卡"><a href="#无线网卡" class="headerlink" title="无线网卡"></a>无线网卡</h3><blockquote><p>网卡可以去某宝搜索 <code>RT3070</code> 和 <code>RT3572</code> 关键词，几十块就可以搞定。</p><p>笔记本的网卡、台式机的网卡和外置的台式机外卡一般都不可使用。</p></blockquote><p>无线网卡需要事先被虚拟机托管。具体步骤为：设备-&gt;USB-&gt;选择你的网卡(一般以 WLAN 结尾)。</p><p>必须是可以使用监听模式的网卡，一般比较推荐 <code>RT3572</code> 型号的网卡(可以监听 2.4GHz 和 5GHz 网段的网络)。如果你不确定你的网卡是否支持监听模式，可以使用如下命令来查看：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前的网卡和 IP 地址，找到以 wlan 开头的网卡，那就是我们外挂的无线网卡</span></span><br><span class="line">ip a</span><br></pre></td></tr></table></figure><p>预期结果</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3: wlan0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记下无线网卡的名称，查看此网卡是否支持监听模式，如果有内容输出则说明此网卡支持监听模式</span></span><br><span class="line">sudo airmon-ng | grep wlan0</span><br></pre></td></tr></table></figure><p>预期结果</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">phy0    wlan0           rt2800usb       Ralink Technology, Corp. RT3572</span><br></pre></td></tr></table></figure><h3 id="aircrack-ng"><a href="#aircrack-ng" class="headerlink" title="aircrack-ng"></a>aircrack-ng</h3><p>Kali-Linux 已经事先安装，但如果你没有 Kali-Linux 的话，也可以在你自己习惯的 Linux 上进行手动安装，具体参见<a href="https://www.aircrack-ng.org/doku.php?id=install_aircrack">这里</a>。</p><p>关于 aircrack-ng 的详细的使用可以使用 <code>aircrack-ng --help</code> 来查看。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是破解能否成功的关键，如果你的字典够好够大，那么你能够破解密码的概率也就越大。</p><h3 id="Kali-Linux-自带字典"><a href="#Kali-Linux-自带字典" class="headerlink" title="Kali-Linux 自带字典"></a>Kali-Linux 自带字典</h3><p>Kali-Linux 自带了几个字典在 <code>/usr/share/wordlists</code> 目录下，我们可以直接使用，但存在较大的局限性，只能跑一些弱密码，一些特殊需求的字典还是需要其他工具生成。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ll /usr/share/wordlists</span><br><span class="line">total 136644</span><br><span class="line">lrwxrwxrwx 1 root root        26 Dec  5 08:41 amass -&gt; /usr/share/amass/wordlists</span><br><span class="line">lrwxrwxrwx 1 root root        25 Dec  5 08:41 dirb -&gt; /usr/share/dirb/wordlists</span><br><span class="line">lrwxrwxrwx 1 root root        30 Dec  5 08:41 dirbuster -&gt; /usr/share/dirbuster/wordlists</span><br><span class="line">lrwxrwxrwx 1 root root        41 Dec  5 08:41 fasttrack.txt -&gt; /usr/share/set/src/fasttrack/wordlist.txt</span><br><span class="line">lrwxrwxrwx 1 root root        45 Dec  5 08:41 fern-wifi -&gt; /usr/share/fern-wifi-cracker/extras/wordlists</span><br><span class="line">lrwxrwxrwx 1 root root        28 Dec  5 08:41 john.lst -&gt; /usr/share/john/password.lst</span><br><span class="line">lrwxrwxrwx 1 root root        27 Dec  5 08:41 legion -&gt; /usr/share/legion/wordlists</span><br><span class="line">lrwxrwxrwx 1 root root        46 Dec  5 08:41 metasploit -&gt; /usr/share/metasploit-framework/data/wordlists</span><br><span class="line">lrwxrwxrwx 1 root root        41 Dec  5 08:41 nmap.lst -&gt; /usr/share/nmap/nselib/data/passwords.lst</span><br><span class="line">-rw-r--r-- 1 root root 139921507 May 31  2022 rockyou.txt</span><br><span class="line">lrwxrwxrwx 1 root root        39 Dec  5 08:41 sqlmap.txt -&gt; /usr/share/sqlmap/data/txt/wordlist.txt</span><br><span class="line">lrwxrwxrwx 1 root root        25 Dec  5 08:41 wfuzz -&gt; /usr/share/wfuzz/wordlist</span><br><span class="line">lrwxrwxrwx 1 root root        37 Dec  5 08:41 wifite.txt -&gt; /usr/share/dict/wordlist-probable.txt</span><br></pre></td></tr></table></figure><h3 id="Crunch-生成字典"><a href="#Crunch-生成字典" class="headerlink" title="Crunch 生成字典"></a>Crunch 生成字典</h3><p>如果在情报侦测阶段，你获取了足够多的信息，比如名字，生日，孩子的名字，宠物，学校等，甚至还知道了密码策略，例如至少8位，必须包含大小写字母等。我们就可以自定义一个有针对性的字典，从而完成爆破的任务。</p><p>Crunch就是这么一个工具，我们利用它可以创建自定义的破解字典，可以和 Hashcat,Join the Ripper,Aircrack-ng 等工具一起使用。如果设置得当，势必能够节约时间。</p><p>更详细的说明和具体使用方法请使用 <code>man crunch</code> 命令来查看。</p><h2 id="fk-the-WiFi"><a href="#fk-the-WiFi" class="headerlink" title="fk the WiFi"></a>fk the WiFi</h2><p>着手开始破解之旅</p><h3 id="网卡开启监听模式"><a href="#网卡开启监听模式" class="headerlink" title="网卡开启监听模式"></a>网卡开启监听模式</h3><blockquote><p>请确保无线网卡已经正确连接</p></blockquote><p>使用如下命令还启动网卡的监听模式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo airmon-ng start wlan0</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网卡信息</span></span><br><span class="line">ip a</span><br></pre></td></tr></table></figure><p>再次查看网卡信息可以发现原先的 <code>wlan0</code> 网卡变成了 <code>wlan0mon</code> 说明网卡已经开启了监听模式。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">wlan0mon: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UNKNOWN group default qlen 1000</span><br></pre></td></tr></table></figure><h3 id="扫描周边-WiFi"><a href="#扫描周边-WiFi" class="headerlink" title="扫描周边 WiFi"></a>扫描周边 WiFi</h3><h4 id="2-4GHz-网段"><a href="#2-4GHz-网段" class="headerlink" title="2.4GHz 网段"></a>2.4GHz 网段</h4><blockquote><p>优先寻找 2.4GHz 网段 WiFi</p></blockquote><p>使用如下命令开始扫描周边的命令，如果只是扫描 2.4GHz 频段的 WiFi 可以使用以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo airodump-ng wlan0mon</span><br></pre></td></tr></table></figure><p>执行完命令之后，网卡就会开始工作，扫描附近的 2.4GHz 的 WiFi，结果如下所示：</p><p><img src="/2023/04/11/WiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/2.4GHzWiFi%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" alt="2.4GHzWiFi扫描结果"></p><p>字段说明：</p><ul><li>CH  9]：当前信道，2.4GHz 一般有14(1~14)个信道。</li><li>[ Elapsed: 12 s ]：表示已经扫描了多久。</li><li>[ 2023-04-10 22:05 ]：当前时间。</li><li>[ display ap+sta+ack：<strong>重要</strong>，在侦测到WPA&#x2F;WPA2握手包的时候会显示</li><li>BSSID：<strong>重要</strong>，接入点的MAC地址，在客户端部分，“（not associated）”表示客户端没有连接到任何接入点。在这种没有连接的状态下，它一直会搜寻接入点。</li><li>PWR：网卡反馈的信号水平，它的数值是驱动决定的，但是离接入点或基站越近，信号数值就会变得越大。如果接入点的PWR是-1，则表示驱动不支持信号水平；如果部分station的PWR是-1，则表示网卡能接收到接入点的数据包，但是却超出了网卡的传输范围。这就意味着我们只能监听到1&#x2F;2的信息交流。如果所有station都是-1，则表明驱动不支持显示信号水平。</li><li>Beacons：接入点发出的公告报文的数量，每个接入点每秒大概发送10个公告包（以最低的速率1M），所以通常相距较远时也能收集到它们。</li><li>#Data：捕捉到的数据包的数量（如果是WEP，则是不同IV的数量），包括数据广播包</li><li>#&#x2F;s：过去10秒每秒接收到的数据包数量</li><li>CH：无线信道（从beacon包中得到），注意：即使固定了信道，有时也会捕捉到其他信道的数据包，这时由于无线电干扰造成的</li><li>MB：接入点支持的最大速度。如果MB&#x3D;11，就是802.1b，如果MB&#x3D;22，就是802.1b+，更高的就是802.1g。</li><li>ENC：表示使用的加密算法。OPN表示没有加密，“WEP？”表示不确定是WEP还是WPA&#x2F;WPA2；WEP表示静态或者动态的WEP,TKIP或者CCMP表示WPA&#x2F;WPA2。</li><li>CIPHER：检测出的密码体系，CCMP,WRAP,TKIP,WEP,WEP40和WEP104中的一种。虽然不是必须的，但是TKIP通常用于WPA，CCMP常用于WPA2。当键字索引大于0时，会显示WEP40。（40位时，索引可以是0-3；104位时，索引需为0）</li><li>AUTH：使用的认证协议。GMT（WPA&#x2F;WPA2 使用单独的认证服务器），SKA（WEP共享密钥） ，PSK（WPA&#x2F;WPA2 预共享密钥），或者OPN（WEP开放认证）</li><li>ESSID：无线网络名称。也叫“SSID”，如果开启SSID隐藏模式，则此项为空。在这种情况下，airodump-ng会尝试通过探测响应和关联请求恢复SSID。</li><li>STATION：每一个已连接或者正尝试连接用户的MAC地址，还没有连接上接入点的用户的BSSID是”not associated”。</li><li>Lost：过去的10秒钟丢失的数据包数量</li><li>Packets：用户发出的数据包数量</li><li>Probes：用户探测的无线网络名称，如果还没有连接那么它是用户正尝试连接的网络名称</li></ul><h4 id="5GHz-网段"><a href="#5GHz-网段" class="headerlink" title="5GHz 网段"></a>5GHz 网段</h4><blockquote><p>注意：破解 WiFi 时一般不选取 5GHz 网段，因为常规的 WiFi 攻击手段对 5GHz 无效，没办法实现效果，此处只作为展示使用。</p></blockquote><p>如果你的网卡支持 5GHz 频段的 WiFi 可以使用以下命令扫描 5GHz 频段的 WiFi(可以使用 <code>iw list</code> 命令来查看网卡支持的 5GHz 频率，一般在 <code>Frequencies</code> 字段中)：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo airodump-ng -C 5180-5825 wlan0mon</span><br></pre></td></tr></table></figure><p>扫描结果如下所示：</p><p><img src="/2023/04/11/WiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/5GHzWiFi%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" alt="5GHzWiFi扫描结果"></p><p>字段与 2.4GHz 的结果类似基本一致，唯一不一样的是 <code>Freq 5540 ]</code>，这个字段表示当前正在扫描的 5GHz 频率。</p><h3 id="抓取握手包"><a href="#抓取握手包" class="headerlink" title="抓取握手包"></a>抓取握手包</h3><blockquote><p>原理：所有的设备想要连接到路由器都需要进行一次握手的过程，在这个过程中路由器和连接设备会发送握手包，我们可以利用握手包来破解路由器的密码。首先就需要攻击路由器上正在连接的设备，使其掉线然后进行重新连接，重新连接时会产生握手包，我们抓取到握手包之后就可以进行后续的破解操作。</p></blockquote><p>当扫描出周边的 WiFi 时，我们就可以挑选出我们的目标 WiFi 了，例如我们这里选择 <code>理工彭于晏</code> 这个小倒霉蛋，根据扫描结果拿到他的 BSSID 和当前哪个信道上有连接设备，使用如下命令来抓取握手包。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo airodump-ng -c 11 --bssid &lt;your_target_mac_address&gt; -w ./test wlan0mon</span><br></pre></td></tr></table></figure><p>这时我们可以另起一个终端窗口来进行 deauth 攻击，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo aireplay-ng -0 20 -a &lt;target_AP_mac&gt; -c &lt;station_mac&gt; wlan0mon</span><br></pre></td></tr></table></figure><ul><li>-0：Deauth 攻击</li><li>-a：目标路由器的 MAC 地址</li><li>-c：表示目标路由器连接的设备 MAC 地址</li></ul><p>效果如下：</p><p><img src="/2023/04/11/WiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/Deauth%E6%94%BB%E5%87%BB.png" alt="Deauth攻击"></p><p>在 Deauth 攻击下，我们最终会拿到握手包，如下所示：</p><p><img src="/2023/04/11/WiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/%E6%8A%93%E5%8F%96%E5%88%B0%E6%8F%A1%E6%89%8B%E5%8C%85.png" alt="抓取到握手包"></p><p>握手包存放的位置为 <code>airodump-ng</code> 命令中 <code>-w</code> 选项的路径，我们可以进入该路径，文件夹里一般包含以下几个文件：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">total 1820</span><br><span class="line">-rw-r--r-- 1 root root 1197167 Dec 29 03:15 test-01.cap</span><br><span class="line">-rw-r--r-- 1 root root     581 Dec 29 03:15 test-01.csv</span><br><span class="line">-rw-r--r-- 1 root root     595 Dec 29 03:15 test-01.kismet.csv</span><br><span class="line">-rw-r--r-- 1 root root    3919 Dec 29 03:15 test-01.kismet.netxml</span><br><span class="line">-rw-r--r-- 1 root root  645700 Dec 29 03:15 test-01.log.csv</span><br></pre></td></tr></table></figure><p>其中 <code>cap</code> 文件最为重要。</p><h3 id="破解密码"><a href="#破解密码" class="headerlink" title="破解密码"></a>破解密码</h3><p>拿到握手包之后，我们就可以使用如下命令开始破解密码了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo aircrack-ng -w /usr/share/wordlists/wifite.txt -b &lt;yout_target_mac&gt; test-01.cap</span><br></pre></td></tr></table></figure><ul><li>-w：字典位置</li><li>-b：目标路由器 MAC 地址</li><li>握手包路径</li></ul><p>执行完毕之后可以看到密码被成功破解，如下所示：</p><p><img src="/2023/04/11/WiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/%E6%89%BE%E5%88%B0%E5%AF%86%E7%A0%81.png" alt="找到密码"></p><p>当然不是每次都这么幸运，如果目标路由器的密码比较复杂的话可能需要很长时间才能破解的出来或者根本破解不出来。</p><h2 id="安全建议"><a href="#安全建议" class="headerlink" title="安全建议"></a>安全建议</h2><ul><li>WiFi 密码越复杂越好</li><li>WiFi 密码不要跟个人信息有关</li><li>把 WiFi 设置成隐藏</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WiFi 密码的破解过程其实不难，难的是密码的破解也就是字典的选取。目标路由器的密码越复杂那么破解起来将会越耗时也越难破解。并且只有暴力破解这一条路可以走，例如彩虹表、GPU 加速等技术只是加速破解的速度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文基于 Oracle VirtualBox&lt;/p&gt;
&lt;p&gt;本文基于 kali-linux-2022.4-virtualbox-amd64&lt;/p&gt;
&lt;p&gt;本文基于 RT3572(同时支持 2.4GHz 和 5GHz) 无线网卡&lt;/p&gt;
&lt;p&gt;本文基</summary>
      
    
    
    
    
    <category term="kali linux" scheme="https://zenvzenv.github.io/tags/kali-linux/"/>
    
    <category term="网络安全" scheme="https://zenvzenv.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="WiFi渗透" scheme="https://zenvzenv.github.io/tags/WiFi%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 夜话(1)</title>
    <link href="https://zenvzenv.github.io/2023/04/04/Java-%E5%A4%9C%E8%AF%9D-1/"/>
    <id>https://zenvzenv.github.io/2023/04/04/Java-%E5%A4%9C%E8%AF%9D-1/</id>
    <published>2023-04-04T11:34:57.000Z</published>
    <updated>2023-04-04T11:34:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天上班时被问到一个问题，题目如下：</p><blockquote><p>给定一个 <code>Set&lt;String&gt;</code> 里面一些列关键字字符串，现要求，给定一个长度 <code>length</code>，要求 <code>Set</code> 中的关键字组成一个用 <code>,</code> 分割的并且不超过给定长度的字符串，但 <code>,</code> 不算字数，每个关键词可以随意组合，每个关键词只能使用一次。</p><p>例如：Set(String) &#x3D; {“你好”, “世界”, “来玩”, “LOL”, “学习”, “天气好”, “明天下雨”},length &#x3D; 5</p><p>其中一个正确的输出为 {“你好,世界”, “来玩,LOL”, “学习,天气好”, “明天下雨”}，答案并不固定，只需要符合要求即可。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们需要记录下 <code>,</code> 的个数，使用 <code>StringBuilder</code> 来构造候选结果集元素，候选结果集元素是包含 <code>,</code> 的全部字符，我们只需要用候选结果集元素减去逗号的个数就能得到真正的字符长度，用此长度来与 <code>length</code> 比较即可。</p><p>此种方法并不是最优解，只是遍历了一遍 <code>Set</code> 集合，并没有主动寻找最优的字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">m1</span><span class="params">(Set&lt;String&gt; keys, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">// 逗号计数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">commaCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 候选结果临时变量</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 结果集</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="comment">// 当前候选结果临时变量的长度减去逗号的个数就等于实际存入的关键字的长度</span></span><br><span class="line">        <span class="comment">// 如果实际存入的关键字小于给定的长度，我们认为该 key 合法并添加到候选结果临时变量中</span></span><br><span class="line">        <span class="keyword">if</span> (tmp.length() - commaCount + key.length() &lt;= length) &#123;</span><br><span class="line">            <span class="comment">// 将当前 key 添加到候选结果中</span></span><br><span class="line">            tmp.append(key).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="comment">// 逗号个数 +1</span></span><br><span class="line">            commaCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果该 key 非法，即加上该 key 会导致候选结果超长，则我们将当前的 tmp 添加到结果集中</span></span><br><span class="line">            result.add(tmp.substring(<span class="number">0</span>, tmp.length() - <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// tmp 重置</span></span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(key).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="comment">// 将逗号数量初始化为 1</span></span><br><span class="line">            commaCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一次边界值考虑</span></span><br><span class="line">    <span class="keyword">if</span> (tmp.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result.add(tmp.substring(<span class="number">0</span>, tmp.length() - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;今天上班时被问到一个问题，题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 &lt;code&gt;Set&amp;lt;String&amp;gt;&lt;/c</summary>
      
    
    
    
    
    <category term="Java 夜话" scheme="https://zenvzenv.github.io/tags/Java-%E5%A4%9C%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>Java 单点应用获取方法调用链路分析</title>
    <link href="https://zenvzenv.github.io/2023/04/03/Java-%E5%8D%95%E7%82%B9%E5%BA%94%E7%94%A8%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90/"/>
    <id>https://zenvzenv.github.io/2023/04/03/Java-%E5%8D%95%E7%82%B9%E5%BA%94%E7%94%A8%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90/</id>
    <published>2023-04-03T01:51:27.000Z</published>
    <updated>2023-04-03T01:51:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 <a href="https://github.com/zenvzenv/slot">slot</a></p><p>本文基于 JDK1.8</p></blockquote><h2 id="方法与线程"><a href="#方法与线程" class="headerlink" title="方法与线程"></a>方法与线程</h2><p>JVM 规范中虚拟机栈为线程私有，每个方法在执行时都会在虚拟机中创建一个栈帧。每一个栈帧表示没有执行完的方法，执行完的的方法，其栈帧会被弹出栈。</p><h2 id="如何存放方法调用链路"><a href="#如何存放方法调用链路" class="headerlink" title="如何存放方法调用链路"></a>如何存放方法调用链路</h2><p>如果想记录应用的方法调用链路，那么首要的问题就是这些调用数据应该存在什么地方才能够被全局访问到，并且是线程隔离的。</p><p>Java 提供 <code>ThreadLocal</code> 来隔离各个线程的私有变量，我们只需要在 <code>ThreadLocal</code> 中村放各个线程的调用 <code>Stack</code> 即可。</p><h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><p>关于链路追踪的原理可以参阅 Google 发布的一篇论文 <a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf">《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》</a></p><p><a href="https://github.com/zenvzenv/slot">slot</a> 的实现较为简单还不是很成熟，只遵循了 <a href="https://opentelemetry.io/">OpenTelemetry</a> 的部分语义，后续会实现 OpenTracing 的全部语义。</p><h3 id="全局-traceId-控制"><a href="#全局-traceId-控制" class="headerlink" title="全局 traceId 控制"></a>全局 traceId 控制</h3><p>具体实现为 <a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/trace/TraceContext.java">TraceContext</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraceContext</span> &#123;</span><br><span class="line">    <span class="comment">// 每个线程的 TraceId 私有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; TRACE_LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 当方法执行结束时需要清理 TraceId</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        TRACE_LOCAL.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取 TraceId</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> String <span class="title function_">getTraceId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> TRACE_LOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 进入方法时会生成全局唯一 TraceId，并存储到线程内存中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setTraceId</span><span class="params">(String traceId)</span> &#123;</span><br><span class="line">        TRACE_LOCAL.set(traceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用链控制"><a href="#调用链控制" class="headerlink" title="调用链控制"></a>调用链控制</h3><p>具体实现为 <a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/trace/TraceManager.java">TraceManager</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraceManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Stack&lt;String&gt;&gt; TRACE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 我们认为根方法的 id 为0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_METHOD_SPAN_ID</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新的方法调用 span，调用栈中只存储 span id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新 span id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> String <span class="title function_">createSpan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前调用栈</span></span><br><span class="line">        Stack&lt;String&gt; stack = TRACE.get();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == stack) &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            TRACE.set(stack);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前调用栈为空，那么则认为该方法为 root method</span></span><br><span class="line">        <span class="comment">// 并创建此次调用链 id</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            TraceContext.setTraceId(ASMUtils.genId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ASMUtils.genId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增一个方法调用栈，并压栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前 span</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> String <span class="title function_">entrySpan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成新的调用栈</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">span</span> <span class="operator">=</span> createSpan();</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;String&gt; spans = TRACE.get();</span><br><span class="line">        <span class="comment">// 压栈</span></span><br><span class="line">        spans.push(span);</span><br><span class="line">        <span class="keyword">return</span> span;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法退出时同时把 span 出栈标识该方法退出调用栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exitSpan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;String&gt; spans = TRACE.get();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == spans || spans.isEmpty()) &#123;</span><br><span class="line">            TraceContext.clear();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈为空则认为本次调用链结束</span></span><br><span class="line">        spans.pop();</span><br><span class="line">        <span class="keyword">if</span> (spans.isEmpty()) &#123;</span><br><span class="line">            TraceContext.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取父 span id，如果当前栈为空，则认为当前方法为 root method</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 该方法应该先于 entrySpan 调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前方法的父 span id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> String <span class="title function_">getParentSpan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;String&gt; spans = TRACE.get();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == spans || spans.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ROOT_METHOD_SPAN_ID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> spans.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>当第一个方法开始执行时，ThreadLocal 中的 Stack 是空的</p> <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-------------------------------------------------------+</span><br><span class="line">|                     ThreadLocal                       |</span><br><span class="line">|     Stack             Stack            Stack          |</span><br><span class="line">|  +-------------+   +-------------+  +-------------+   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  |             |   |             |  |             |   |</span><br><span class="line">|  +-------------+   +-------------+  +-------------+   |</span><br><span class="line">+-------------------------------------------------------+</span><br></pre></td></tr></table></figure></li><li><p>接下来我们只看一个线程，当一个方法被线程执行时，我们会调用 <code>entrySpan()</code> 方法在栈中压入一个 SpanId( 特殊的根方法的 SpanId 为0)，如果是新的调用链的话还会生成 TraceId。</p> <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-------------------+        +-------------------+</span><br><span class="line">|    ThreadLocal    |        |    ThreadLocal    |</span><br><span class="line">|                   |        |                   |</span><br><span class="line">|                   |        | +---------------+ |</span><br><span class="line">|                   |        | |               | |</span><br><span class="line">|     Stack         |        | |  TraceId      | |</span><br><span class="line">|  +-------------+  |        | |               | |</span><br><span class="line">|  |             |  |        | +---------------+ |</span><br><span class="line">|  |             |  |        +-------------------+</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |</span><br><span class="line">|  | +---------+ |  |</span><br><span class="line">|  | | SpanId  | |  |</span><br><span class="line">|  | +---------+ |  |</span><br><span class="line">|  +-------------+  |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure></li><li><p>当第二个方法或更多方法被线程执行时，我们会为每一个方法(<code>entrySpan()</code>)生成一个 SpanId 并压入栈中(不存入对象是为了节约内存空间)，并将当前栈顶的 SpanId 设置为当前出栈 Span 的父 id(<code>getParentSpan()</code>)。</p> <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+----------------------------+</span><br><span class="line">| ThreadLocal                |</span><br><span class="line">|                            |</span><br><span class="line">|                +-------------------+</span><br><span class="line">|                |           |       |</span><br><span class="line">|                |           |       |</span><br><span class="line">|     Stack      |           |       |</span><br><span class="line">|         +---------------+  |       |</span><br><span class="line">|         |      |        |  +-------+------+</span><br><span class="line">|         |      |        |  ||  SpanId     |</span><br><span class="line">|         |      |        |  ||             |</span><br><span class="line">|         |      |        |  +--------------+</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         |      |        |  |</span><br><span class="line">|         | +----v------+ |  |</span><br><span class="line">|         | |           | |  |</span><br><span class="line">|         | |   SpanId  +--------------------+</span><br><span class="line">|         | +-----------+ |  |               |</span><br><span class="line">|         |               |  |    ParentId   |</span><br><span class="line">|         | +-----------+ |  |               |</span><br><span class="line">|         | |           | |  |               |</span><br><span class="line">|         | |   SpanId  &lt;--------------------+</span><br><span class="line">|         | +-----------+ |  |               |</span><br><span class="line">|         |               |  |               |</span><br><span class="line">|         | +-----------+ |  |   ParendId    |</span><br><span class="line">|         | |           | |  |               |</span><br><span class="line">|    0 &lt;----+   SpanId  &lt;--------------------+</span><br><span class="line">|         | +-----------+ |  |</span><br><span class="line">|         +---------------+  |</span><br><span class="line">|                            |</span><br><span class="line">+----------------------------+</span><br></pre></td></tr></table></figure><p> 即使是递归方法，每次方法的调用都会生成新的 SpanId，栈的深度应该由业务系统来考虑，栈过深的话会导致 JVM 出现 StackOverflow 的错误。</p></li><li><p><code>exitSpan()</code> 方法会检测每一个方法出栈时当前栈的状态，如果栈中没有数据，我们认为此次调用链结束，我们将把 TraceId 也进行弹出，做最后的收尾工作。</p> <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-------------------+                            +---------------+</span><br><span class="line">|    ThreadLocal    |                            |  ThreadLocal  |</span><br><span class="line">|                   |                            |               |  pop</span><br><span class="line">|                   |                            |        +--------------&gt;</span><br><span class="line">|  +-------------+  |                            |        |      |</span><br><span class="line">|  |    Stack    |  |                            |  +-----+----+ |</span><br><span class="line">|  |             |  |                            |  |          | |</span><br><span class="line">|  |             |  |                            |  |  TraceId | |</span><br><span class="line">|  |             |  |                            |  |          | |</span><br><span class="line">|  |             |  |                            |  |          | |</span><br><span class="line">|  |             |  |                            |  +----------+ |</span><br><span class="line">|  |             |  |                            |               |</span><br><span class="line">|  |             |  |                            |               |</span><br><span class="line">|  |             |  |                            |               |</span><br><span class="line">|  |             |  |                            |               |</span><br><span class="line">|  |             |  |                            |               |</span><br><span class="line">|  |             |  |                            |               |</span><br><span class="line">|  |             |  |                            +---------------+</span><br><span class="line">|  |             |  |</span><br><span class="line">|  |             |  |      pop</span><br><span class="line">|  |     +-----------------------&gt;</span><br><span class="line">|  |     |       |  |</span><br><span class="line">|  |     |       |  |</span><br><span class="line">|  |     |       |  |</span><br><span class="line">|  |     |       |  |</span><br><span class="line">|  |     |       |  |</span><br><span class="line">|  |     |       |  |</span><br><span class="line">|  | +---+-----+ |  |</span><br><span class="line">|  | | SpanId  | |  |</span><br><span class="line">|  | |         | |  |</span><br><span class="line">|  | +---------+ |  |</span><br><span class="line">|  +-------------+  |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为所有的方法都在线程中执行，我们使用线程私有的并且可以全局访问的 <code>ThreadLocal</code> 对象来追踪方法的链路调用，并使用 <code>Stack</code> 来组织数据的调用关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文基于 &lt;a href=&quot;https://github.com/zenvzenv/slot&quot;&gt;slot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文基于 JDK1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;方法与线程&quot;&gt;&lt;a href=&quot;#方法与线程</summary>
      
    
    
    
    
    <category term="slot" scheme="https://zenvzenv.github.io/tags/slot/"/>
    
    <category term="埋点" scheme="https://zenvzenv.github.io/tags/%E5%9F%8B%E7%82%B9/"/>
    
    <category term="链路追踪" scheme="https://zenvzenv.github.io/tags/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>hdfs 如何精细化为用户赋权</title>
    <link href="https://zenvzenv.github.io/2023/03/28/hdfs-%E5%A6%82%E4%BD%95%E7%B2%BE%E7%BB%86%E5%8C%96%E4%B8%BA%E7%94%A8%E6%88%B7%E8%B5%8B%E6%9D%83/"/>
    <id>https://zenvzenv.github.io/2023/03/28/hdfs-%E5%A6%82%E4%BD%95%E7%B2%BE%E7%BB%86%E5%8C%96%E4%B8%BA%E7%94%A8%E6%88%B7%E8%B5%8B%E6%9D%83/</id>
    <published>2023-03-28T02:16:57.000Z</published>
    <updated>2023-03-28T02:16:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 <a href="https://hadoop.apache.org/docs/r3.3.5/">Hadoop-3.3.5</a></p></blockquote><h2 id="hdfs-权限模型"><a href="#hdfs-权限模型" class="headerlink" title="hdfs 权限模型"></a>hdfs 权限模型</h2><blockquote><p>具体可以参阅 <a href="https://hadoop.apache.org/docs/r3.3.5/hadoop-project-dist/hadoop-hdfs/HdfsPermissionsGuide.html">HDFS Permissions Guide</a></p></blockquote><p>hdfs 实现了一套 POSIX 模型。权限分为可读权限(r)、可写权限(w)和可执行权限(x)。</p><ul><li><p>对于文件，需要可读权限才能读取文件，并且需要可写权限才可以往文件中写或者追加内容，hdfs 不存在可执行文件的概念。</p></li><li><p>对于目录，需要可读权限才能列出目录的内容，可写权限可以创建或删除文件或目录，并且需要可执行权限才能访问目录子内容。</p></li></ul><p>每个文件和目录都与所有者和一个组关联。 该文件或目录为所有者(owner)，组成员的其他用户(group)以及所有其他用户(other)具有单独的权限。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">drwx(owner)r-x(group)r-x(other) -   hdfs hdfs   0   2023-03-27 00:00 /user</span><br></pre></td></tr></table></figure><p>HDFS 还为 POSIX ACL（访问控制列表）提供了可选的支持，以增强对特定命名用户或命名组的详细规则的文件权限。这也是以最小粒度分配文件权限的基础。</p><h2 id="hdfs-用户"><a href="#hdfs-用户" class="headerlink" title="hdfs 用户"></a>hdfs 用户</h2><p>hdfs 其实并不提供用户功能，一般的，hdfs 使用的是 Linux 的用户作为 hdfs 的用户，例如你使用 root 用户登录，那么在你使用 hdfs 命令或向 yarn 提交任务时，你的用户就是 root。</p><blockquote><p>root 在 hdfs 中并不是超级用户，超级用户在 <a href="https://hadoop.apache.org/docs/r3.3.5/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml">hdfs-site.xml</a> 中被 <code>dfs.cluster.administrators</code> 被指定，超级用户组被 <code>dfs.permissions.superusergroup</code> 指定</p></blockquote><p>特殊的，你也可以使用非 Linux 的用户来操作 hdfs，只需要在当前终端执行以下命令来切换用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HADOOP_USER_NAME=&lt;your_hdfs_username&gt;</span><br><span class="line">export HADOOP_USER_NAME=a</span><br><span class="line">export HADOOP_USER_NAME=b</span><br></pre></td></tr></table></figure><p><code>HADOOP_USER_NAME</code> 用户命可以任意指定，可能会出现 hdfs 的权限问题。</p><h2 id="用户访问权限"><a href="#用户访问权限" class="headerlink" title="用户访问权限"></a>用户访问权限</h2><p>如果你使用了 <code>export HADOOP_USER_NAME=&lt;your_hdfs_username&gt;</code> 来切换用户名之后，可能会出现某些文件或文件夹读写出现问题。</p><p>例如，你 <code>export HADOOP_USER_NAME=a</code> 切换成了 <code>a</code> 用户，当你向 yarn 提交任务的时候，hdfs 会在 <code>/user</code> 目录下新建一个 <code>/user/a</code> 的用户工作目录，但 <code>/user</code> 目录的权限一般为 <code>rwxr-xr-x</code>，也就是说 <code>a</code> 用户是没有写权限，根据 POXIS 模型可知，没有写权限就不可以在 <code>/user</code> 目录下新建文件夹，从而会导致任务失败。</p><p>我们不能使用 <code>hdfs dfs -chmod 757 /user</code> 命令将 <code>/user</code> 目录改为 <code>rwxr-xrwx</code> 权限，这样做是不安全的，因为这样做会影响到全部用户，导致所有其他用户对 <code>/user</code> 都可写，这不是我们所期望的结果，我们应该秉承最小权限的原则来对用户赋予权限。这时我们就需要针对单个目录或文件对单个用户赋予一些特殊权限，hdfs 提供了 ACLs 功能来帮我们解决相关场景。</p><h2 id="ACLs-概述"><a href="#ACLs-概述" class="headerlink" title="ACLs 概述"></a>ACLs 概述</h2><p>HDFS在传统的POSIX权限模型之外，还支持POSIX ACLs (Access Control Lists)。通过ACLs可以做到更加灵活的授权。</p><p>默认情况下，启用了对 ACLs 的支持，Namenode允许创建ACL。 要禁用对ACL的支持，请在 NameNode 配置中设置 <code>dfs.namenode.acls.enable</code> 为 <code>false。</code></p><h3 id="ACLs-条目"><a href="#ACLs-条目" class="headerlink" title="ACLs 条目"></a>ACLs 条目</h3><p>每个 ACL 条目都为特定的用户或组命名，并授予或拒绝该特定用户或组的 <code>rwx</code>，可以执行 <code>hdfs dfs -getfacl &lt;your_hdfs_dir&gt;</code> 来获取某个文件或文件夹的 ACLs 信息，具体条目如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># file: filepath</span><br><span class="line"># owner: hdfs</span><br><span class="line"># group: hdfs</span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::rwx</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>#file</td><td>&#x2F;user</td><td>文件名</td></tr><tr><td>#owner</td><td>hdfs</td><td>所有者</td></tr><tr><td>#group</td><td>hdfs</td><td>所有组</td></tr><tr><td>user</td><td>user::rwx</td><td>用户权限</td></tr><tr><td>group</td><td>group::r-x</td><td>组权限</td></tr><tr><td>mask</td><td>mask::rwx</td><td></td></tr><tr><td>other</td><td>other::r-x</td><td>其他人权限</td></tr></tbody></table><h3 id="最小-ACLs-与扩展-ACLs"><a href="#最小-ACLs-与扩展-ACLs" class="headerlink" title="最小 ACLs 与扩展 ACLs"></a>最小 ACLs 与扩展 ACLs</h3><p>如果一个文件或文件夹的 ACLs 条目与 POXIS 模型一一对应，即 ACLs 条目只包含一条 user,group,other，则称为<strong>最小 ACLs</strong>，如果 ACLs 条目包含超过三条，则称为<strong>扩展 ACLs</strong>。</p><h2 id="ACL-权限操作"><a href="#ACL-权限操作" class="headerlink" title="ACL 权限操作"></a>ACL 权限操作</h2><p>对特定用户赋权就是在对最小 ACLs 变为扩展 ACLs，hdfs 提供相关命令来帮我们实现相关操作。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -setfacl [-R] [-b |-k -m |-x &lt;acl_spec&gt; &lt;path&gt;] |[--set &lt;acl_spec&gt; &lt;path&gt;]</span><br></pre></td></tr></table></figure><ul><li>-R: 以递归方式将操作应用于所有文件和目录。<strong>常用</strong>。</li><li>-b: 删除基本ACL条目以外的所有条目。保留用户，组和其他条目以与权限位兼容。</li><li>-k: 删除默认ACL。<code>default:</code> 开头的条目。</li><li>-m: 修改ACL。新条目将添加到ACL，并保留现有条目。<strong>常用</strong>。</li><li>-x: 删除指定的ACL条目。保留其他ACL条目。<strong>常用</strong>。</li><li>–set: 完全替换ACL，丢弃所有现有条目。 acl_spec 必须包含用户，组和其他条目，以便与权限位兼容。</li><li>acl_spec: 逗号分隔的ACL条目列表。</li><li>path: 要修改的文件或目录。</li></ul><h3 id="赋权"><a href="#赋权" class="headerlink" title="赋权"></a>赋权</h3><p>我们可以执行如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -setfacl -m user:&lt;your_hdfs_username&gt;:rwx &lt;your_hdfs_path&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -setfacl -m user:test:rwx /user</span><br></pre></td></tr></table></figure><p>这样就将 <code>\user</code> 目录的读、写和执行权限赋予给了 <code>test</code> 用户。此时可以执行 <code>hdfs dfs -getfacl /user</code> 命令查看 <code>/user</code> 目录的 ACLs 信息。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># file: /user</span><br><span class="line"># owner: hdfs</span><br><span class="line"># group: hdfs</span><br><span class="line">user::rwx</span><br><span class="line">user:test:rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::r-x</span><br></pre></td></tr></table></figure><blockquote><p>ACL条目由类型，可选名称和权限字符串组成。 为了显示清晰，’:’用作每个字段之间的定界符。</p></blockquote><h3 id="取消权限"><a href="#取消权限" class="headerlink" title="取消权限"></a>取消权限</h3><p>我们可以执行如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -setfacl -x user:&lt;your_hdfs_username&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -setfacl -x user:test /user</span><br></pre></td></tr></table></figure><p>这样就将 <code>test</code> 用户的 <code>\user</code> 目录的读、写和执行权限收回。此时可以执行 <code>hdfs dfs -getfacl /user</code> 命令查看 <code>/user</code> 目录的 ACLs 信息。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># file: /user</span><br><span class="line"># owner: hdfs</span><br><span class="line"># group: hdfs</span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::r-x</span><br></pre></td></tr></table></figure><h2 id="查看-ACLs-权限"><a href="#查看-ACLs-权限" class="headerlink" title="查看 ACLs 权限"></a>查看 ACLs 权限</h2><p>我们可以使用如下命令来查看：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -getfacl [-R] &lt;path&gt;</span><br></pre></td></tr></table></figure><ul><li>-R: 以递归方式列出所有文件和目录的ACL。</li><li>path: 要列出的文件或目录。</li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -getfacl /user</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># file: /user</span><br><span class="line"># owner: hdfs</span><br><span class="line"># group: hdfs</span><br><span class="line">user::rwx</span><br><span class="line">user:test:rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::r-x</span><br></pre></td></tr></table></figure><h2 id="延申阅读"><a href="#延申阅读" class="headerlink" title="延申阅读"></a>延申阅读</h2><ol><li><a href="https://hadoop.apache.org/docs/r3.3.5/hadoop-project-dist/hadoop-hdfs/HdfsPermissionsGuide.html">HDFS Permissions Guide</a></li><li><a href="https://toutiao.io/posts/1ncrik/preview">一篇文章搞懂 HDFS 权限管理</a></li><li><a href="https://blog.51cto.com/u_13193683/2992046">HDFS ACL权限设置</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文基于 &lt;a href=&quot;https://hadoop.apache.org/docs/r3.3.5/&quot;&gt;Hadoop-3.3.5&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;hdfs-权限模型&quot;&gt;&lt;a href=&quot;#hdfs-权</summary>
      
    
    
    
    
    <category term="hdfs" scheme="https://zenvzenv.github.io/tags/hdfs/"/>
    
    <category term="hadoop" scheme="https://zenvzenv.github.io/tags/hadoop/"/>
    
    <category term="auth" scheme="https://zenvzenv.github.io/tags/auth/"/>
    
  </entry>
  
  <entry>
    <title>Apache Livy 如何将 SparkSQL 结果作为 json 返回的方法分享</title>
    <link href="https://zenvzenv.github.io/2023/03/23/Apache-Livy-%E5%A6%82%E4%BD%95%E5%B0%86-SparkSQL-%E7%BB%93%E6%9E%9C%E4%BD%9C%E4%B8%BA-json-%E8%BF%94%E5%9B%9E%E7%9A%84%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/"/>
    <id>https://zenvzenv.github.io/2023/03/23/Apache-Livy-%E5%A6%82%E4%BD%95%E5%B0%86-SparkSQL-%E7%BB%93%E6%9E%9C%E4%BD%9C%E4%B8%BA-json-%E8%BF%94%E5%9B%9E%E7%9A%84%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/</id>
    <published>2023-03-23T02:40:23.000Z</published>
    <updated>2023-03-23T02:40:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 Apache Livy-0.8.0-incubating-SNAPSHOT,Apache Spark-3.3.1,Apache Hadoop-3.3.4<br>读者需要自行编译相关版本</p></blockquote><h2 id="Apache-Livy"><a href="#Apache-Livy" class="headerlink" title="Apache Livy"></a>Apache Livy</h2><blockquote><p>livy 的默认端口为 8998</p></blockquote><p><a href="https://livy.apache.org/">Apache Livy</a> 是一项服务，可通过 REST 接口与 Spark 集群轻松交互。 它支持通过简单的 REST 接口或 RPC 客户端库轻松提交 Spark 作业或 Spark 代码片段、同步或异步结果检索以及 Spark 上下文管理。<code>Apache Livy</code> 还简化了 Spark 与应用程序服务器之间的交互，从而使 Spark 能够用于交互式 Web&#x2F;移动应用程序。</p><p>livy 的相关<a href="https://livy.apache.org/get-started/">配置</a>和<a href="https://livy.apache.org/docs/latest/rest-api.html">使用</a>还请读者自行阅读。</p><h2 id="Apache-Spark"><a href="#Apache-Spark" class="headerlink" title="Apache Spark"></a>Apache Spark</h2><p><a href="https://spark.apache.org/">Apache Spark</a> 是一种多语言引擎，用于在单节点机器或集群上执行数据工程、数据科学和机器学习。</p><p>spark sql 的相关<a href="https://spark.apache.org/docs/latest/">使用</a>和<a href="https://spark.apache.org/docs/latest/configuration.html">配置</a>还请读者自行阅读。</p><h2 id="livy-结果返回格式说明"><a href="#livy-结果返回格式说明" class="headerlink" title="livy 结果返回格式说明"></a>livy 结果返回格式说明</h2><blockquote><p>所有操作均可通过接口测试工具 PostMan 进行</p></blockquote><p>我们主要会想要获取每个 statement 的执行结果，statement 的完整结构体可以在 <a href="https://livy.apache.org/docs/latest/rest-api.html#statement">Statement</a> 查看，所涉及的接口为 <code>GET /sessions/&#123;sessionId&#125;/statements/&#123;statementId&#125;</code>。</p><p>statement 的结构体中有 <code>output(Statement Output)</code> 子结构体，<code>output</code> 中有 <code>data</code> 子结构体，该结构体返回默认协议为 <code>text/plain</code>，此结构体还有两个可选的协议，分别为 <code>application/vnd.livy.table.v1+json</code> 和 <code>application/json</code>。</p><h3 id="text-plain"><a href="#text-plain" class="headerlink" title="text&#x2F;plain"></a>text&#x2F;plain</h3><p>该协议下是将 Spark Shell 返回的结果直接返回，具有较差的可读性，无法进行程序解析，示例如下(本例使用了 <a href="https://github.com/crealytics/spark-excel">spark 读取 excel 的组件</a>)：</p><p>请求参数为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;import org.apache.spark.sql.types.&#123;StructType,StructField,StringType,IntergerType&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;val schema = StructType(List(tructField(\&quot;id\&quot;, StringType, nullable = false),StructField(\&quot;name\&quot;, StringType, nullable = false),StructField(\&quot;age\&quot;, IntegerType, nullable = false),StructField(\&quot;gender\&quot;, StringType, nullable = false),StructField(\&quot;cls\&quot;, StringType, nullable = false)))&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;val excelDF = spark.read.format(\&quot;com.crealytics.spark.excel\&quot;).option(\&quot;dataAddress\&quot;, \&quot;&#x27;学生信息&#x27;!A2:E6\&quot;).option(\&quot;useHeader\&quot;, \&quot;false\&quot;) .schema(schema).load(filePath)&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;excelDF.show&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中 <code>filepath</code> 是实现上传到 hdfs 的 excel 文件。excel 文件内容如下：</p><table><thead><tr><th>编号</th><th>姓名</th><th>年龄</th><th>性别</th><th>班级</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>12</td><td>男</td><td>202101</td></tr><tr><td>2</td><td>b</td><td>12</td><td>女</td><td>202101</td></tr></tbody></table><p>返回值为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;excelDF.show&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;available&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;execution_count&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;text/plain&quot;</span><span class="punctuation">:</span> <span class="string">&quot;+----+----+---+------+------+\n|  id|name|age|gender|   cls|\n+----+----+---+------+------+\n|??|??|  0|  ??|  ??|\n|   1|   a| 12|    ?|202101|\n|   2|   b| 13|    ?|202101|\n|   3|   c| 14|    ?|202101|\n|   4|   d| 15|    ?|202101|\n|   5|   e| 16|    ?|202101|\n+----+----+---+------+------+\n\n&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;progress&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;started&quot;</span><span class="punctuation">:</span> <span class="number">1679553013036</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;completed&quot;</span><span class="punctuation">:</span> <span class="number">1679553052620</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="application-json"><a href="#application-json" class="headerlink" title="application&#x2F;json"></a>application&#x2F;json</h3><p>该协议下 livy 会将 Spark Shell 返回的结果转换为 json 返回，为程序解析提供可能。<strong>但需要注意的是</strong>此协议并非适用所有的场景，该协议只适用于返回的是 <code>Array</code> 或 <code>List</code> 数据结构，否则会报无法转换为 json 数据结构的错误，此处为<a href="https://github.com/apache/incubator-livy/blob/45e07fec68f2b9ad1dc7ebce8db08ad8a778dddc/repl/src/test/scala/org/apache/livy/repl/PythonInterpreterSpec.scala#L102">官方示例</a>。我的示例如下(本例使用了 <a href="https://github.com/crealytics/spark-excel">spark 读取 excel 的组件</a>)：</p><p>请求参数：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;import org.apache.spark.sql.types.&#123;StructType,StructField,StringType,IntergerType&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;val schema = StructType(List(tructField(\&quot;id\&quot;, StringType, nullable = false),StructField(\&quot;name\&quot;, StringType, nullable = false),StructField(\&quot;age\&quot;, IntegerType, nullable = false),StructField(\&quot;gender\&quot;, StringType, nullable = false),StructField(\&quot;cls\&quot;, StringType, nullable = false)))&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;val excelDF = spark.read.format(\&quot;com.crealytics.spark.excel\&quot;).option(\&quot;dataAddress\&quot;, \&quot;&#x27;学生信息&#x27;!A2:E6\&quot;).option(\&quot;useHeader\&quot;, \&quot;false\&quot;) .schema(schema).load(filePath)&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;val result = excelDF.collect\n%json result&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中 <code>filepath</code> 是实现上传到 hdfs 的 excel 文件。excel 文件内容如下：</p><table><thead><tr><th>编号</th><th>姓名</th><th>年龄</th><th>性别</th><th>班级</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>12</td><td>男</td><td>202101</td></tr><tr><td>2</td><td>b</td><td>12</td><td>女</td><td>202101</td></tr></tbody></table><p>返回值为(内容有删减)：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">17</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;val result = excelDF.collect\n%json a&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;available&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;execution_count&quot;</span><span class="punctuation">:</span> <span class="number">17</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;application/json&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nullable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nullable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;age&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nullable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gender&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nullable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cls&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nullable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;编号&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;姓名&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;性别&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;班级&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nullable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nullable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;age&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nullable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gender&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nullable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cls&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nullable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;男&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;202101&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;progress&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;started&quot;</span><span class="punctuation">:</span> <span class="number">1675671786024</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;completed&quot;</span><span class="punctuation">:</span> <span class="number">1675671786321</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="application-vnd-livy-table-v1-json"><a href="#application-vnd-livy-table-v1-json" class="headerlink" title="application&#x2F;vnd.livy.table.v1+json"></a>application&#x2F;vnd.livy.table.v1+json</h3><p>此协议使用条件较为苛刻，返回值的类型需要为 <code>List</code>，且数据格式需要一致，如果不符合数据结构的数据被接收到则会报 <code>table rows have different types</code> 错。此处为<a href="https://github.com/apache/incubator-livy/blob/45e07fec68f2b9ad1dc7ebce8db08ad8a778dddc/repl/src/test/scala/org/apache/livy/repl/PythonInterpreterSpec.scala#L116">官方示例</a>。我的示例如下：</p><p>输入参数为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;val a = List((1,\&quot;a\&quot;,0.12),(3,\&quot;b\&quot;,0.63))\n%table a&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回值为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;val a = List((1,\&quot;a\&quot;,0.12),(3,\&quot;b\&quot;,0.63))\n%table a&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;available&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;execution_count&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;application/vnd.livy.table.v1+json&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;headers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BIGINT_TYPE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_1&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;STRING_TYPE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_2&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DOUBLE_TYPE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_3&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">[</span></span><br><span class="line">                        <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="number">0.12</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">[</span></span><br><span class="line">                        <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;b&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="number">0.63</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;progress&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;started&quot;</span><span class="punctuation">:</span> <span class="number">1679553786494</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;completed&quot;</span><span class="punctuation">:</span> <span class="number">1679553789663</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果想 livy 把 SparkSQL 的结果按 json 结果返回只需要在相应的 <code>spark.sql().collect</code> 或 <code>df.collect</code> 语句后面追加上 <code>\n%json &lt;变量名&gt;</code> 即可。</p><p><strong>注意</strong>：任何赋值、无返回值的语句、返回值不符合规范的语句使用 <code>\n%json &lt;变量名&gt;</code> 将会报 <code>Failed to convert value into JSON value</code> 错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文基于 Apache Livy-0.8.0-incubating-SNAPSHOT,Apache Spark-3.3.1,Apache Hadoop-3.3.4&lt;br&gt;读者需要自行编译相关版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    
    <category term="Apache Livy" scheme="https://zenvzenv.github.io/tags/Apache-Livy/"/>
    
    <category term="Apache Spark" scheme="https://zenvzenv.github.io/tags/Apache-Spark/"/>
    
    <category term="经验" scheme="https://zenvzenv.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Java 无痕埋点实现思路分享-javaagent篇</title>
    <link href="https://zenvzenv.github.io/2023/03/22/Java-%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-javaagent%E7%AF%87/"/>
    <id>https://zenvzenv.github.io/2023/03/22/Java-%E6%97%A0%E7%97%95%E5%9F%8B%E7%82%B9%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-javaagent%E7%AF%87/</id>
    <published>2023-03-22T01:17:51.000Z</published>
    <updated>2023-03-22T01:17:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章基于我的开源 <a href="https://github.com/zenvzenv/slot">slot</a> 工程。<br>本文基于 jdk8 编写</p></blockquote><h2 id="埋点系统对比"><a href="#埋点系统对比" class="headerlink" title="埋点系统对比"></a>埋点系统对比</h2><p>一般的，埋点系统可分为两大类：侵入式埋点和无侵入式埋点。</p><h3 id="侵入式埋点"><a href="#侵入式埋点" class="headerlink" title="侵入式埋点"></a>侵入式埋点</h3><p>一般通过 SDK 来提供埋点能力。</p><h4 id="侵入式埋点优点"><a href="#侵入式埋点优点" class="headerlink" title="侵入式埋点优点"></a>侵入式埋点优点</h4><ol><li><p>埋点粒度可以随意控制，想在哪埋点就在哪埋点</p></li><li><p>使用简单，开发人员根据需要在指定的业务代码处调用 API 即可</p></li></ol><h4 id="侵入式埋点缺点"><a href="#侵入式埋点缺点" class="headerlink" title="侵入式埋点缺点"></a>侵入式埋点缺点</h4><ol><li><p>需要对业务代码进行改造，可能会需要重新进行回归测试和重新发版</p></li><li><p>对业务人员不友好，所有的埋点操作都需要通过研发人员进行操作，对于业务的响应有滞后</p></li></ol><h3 id="无侵入埋点"><a href="#无侵入埋点" class="headerlink" title="无侵入埋点"></a>无侵入埋点</h3><p>一般通过 agent 来实现。</p><h4 id="无侵入埋点优点"><a href="#无侵入埋点优点" class="headerlink" title="无侵入埋点优点"></a>无侵入埋点优点</h4><ol><li><p>无需对原有的业务代码进行改造</p></li><li><p>对业务人员较友好，业务人员可以配置需要埋点的内容</p></li></ol><h4 id="无侵入埋点缺点"><a href="#无侵入埋点缺点" class="headerlink" title="无侵入埋点缺点"></a>无侵入埋点缺点</h4><ol><li><p>埋点粒度无法控制，只能依托于埋点 agent 的实现粒度。</p></li><li><p>埋点的时效性只能依托于埋点 agent 实现，如果是通过 javaagent 来实现，那么需要重启应用来刷新埋点配置，如果是 attach 来实现则无需重启应用。</p></li></ol><h2 id="javaagent"><a href="#javaagent" class="headerlink" title="javaagent"></a>javaagent</h2><blockquote><p>在这片文章中对于 javaagent 只做简单介绍，无痕埋点的思路是本篇文章的重点。</p><p>如果读者想深入了解 javaagent 可自行搜索相关资料。</p></blockquote><p>jvm 允许我们通过 javaagent 在程序启动的过程中对加载的 class 进行修改，这给我们的无痕埋点提供了入口，javaagent是<strong>slot 实现无痕埋点的基石</strong>。</p><p>javaagent 主要包含三个部分，分别是：</p><ul><li>Manifest</li><li>Agent Class</li><li>ClassFileTransformer</li></ul><h3 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h3><p>jvm 要求 javaagent 的 jar 包中必须含有 Manifest 说明文件。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>我们将 Manifest 定义的属性分成了三组：基础、能力和特殊情况。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">                                       ┌─── Premain-Class</span><br><span class="line">                       ┌─── Basic ─────┤</span><br><span class="line">                       │               └─── Agent-Class</span><br><span class="line">                       │</span><br><span class="line">                       │               ┌─── Can-Redefine-Classes</span><br><span class="line">                       │               │</span><br><span class="line">Manifest Attributes ───┼─── Ability ───┼─── Can-Retransform-Classes</span><br><span class="line">                       │               │</span><br><span class="line">                       │               └─── Can-Set-Native-Method-Prefix</span><br><span class="line">                       │</span><br><span class="line">                       │               ┌─── Boot-Class-Path</span><br><span class="line">                       └─── Special ───┤</span><br><span class="line">                                       └─── Launcher-Agent-Class</span><br></pre></td></tr></table></figure><p>主要参数说明：</p><ul><li><code>Premain-Class</code>: When an agent is specified at JVM launch time this attribute specifies the agent class. That is, the class containing the premain method. When an agent is specified at JVM launch time this attribute is required. If the attribute is not present the JVM will abort. Note: this is a class name, not a file name or path.</li><li><code>Agent-Class</code>: If an implementation supports a mechanism to start agents sometime after the VM has started then this attribute specifies the agent class. That is, the class containing the agentmain method. This attribute is required, if it is not present the agent will not be started. Note: this is a class name, not a file name or path.</li><li><code>Can-Redefine-Classes</code>: <code>Boolean</code> (<code>true</code> or <code>false</code>, case irrelevant). Is the ability to redefine classes needed by this agent. Values other than true are considered false. This attribute is optional, the default is false.</li><li><code>Can-Retransform-Classes</code>: <code>Boolean</code> (<code>true</code> or <code>false</code>, case irrelevant). Is the ability to retransform classes needed by this agent. Values other than <code>true</code> are considered <code>false</code>. This attribute is optional, the default is <code>false</code>.</li><li><code>Can-Set-Native-Method-Prefix</code>: <code>Boolean</code> (<code>true</code> or <code>false</code>, case irrelevant). Is the ability to set native method prefix needed by this agent. Values other than <code>true</code> are considered <code>false</code>. This attribute is optional, the default is <code>false</code>.</li><li><code>Boot-Class-Path</code>: A list of paths to be searched by the bootstrap class loader. Paths represent directories or libraries (commonly referred to as JAR or zip libraries on many platforms). These paths are searched by the bootstrap class loader after the platform specific mechanisms of locating a class have failed. Paths are searched in the order listed. Paths in the list are separated by one or more spaces. A path takes the syntax of the path component of a hierarchical URI. The path is absolute if it begins with a slash character (<code>/</code>), otherwise it is relative. A relative path is resolved against the absolute path of the agent JAR file. Malformed and non-existent paths are ignored. When an agent is started sometime after the VM has started then paths that do not represent a JAR file are ignored. This attribute is optional.</li><li><code>Launcher-Agent-Class</code>: If an implementation supports a mechanism to start an application as an executable JAR then the main manifest may include this attribute to specify the class name of an agent to start before the application <code>main</code> method is invoked.</li><li><strong>此文件最后必须要有行样换行</strong></li></ul><p><code>slot</code> 工程的 Manifest 文件如下所示：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: zenv.slot.SlotAgentBootstrap</span><br><span class="line">Power-By: zhengwei AKA zenv</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Class-Path: conf/ lib/slot-repackage-disruptor-1.0.jar lib/slot-repack</span><br><span class="line"> age-logger-1.0.jar</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Created-By: Maven Jar Plugin 3.2.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何生成"><a href="#如何生成" class="headerlink" title="如何生成"></a>如何生成</h3><h4 id="maven-插件"><a href="#maven-插件" class="headerlink" title="maven 插件"></a>maven 插件</h4><p>可以通过 <code>maven-jar-plugin</code> 插件来帮助我们生成 Manifest 文件，相关配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>resources/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Power-By</span>&gt;</span>zhengwei AKA zenv<span class="tag">&lt;/<span class="name">Power-By</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Manifest-Version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">Manifest-Version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>zenv.slot.SlotAgentBootstrap<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Class-Path</span>&gt;</span>conf/<span class="tag">&lt;/<span class="name">Class-Path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 <code>manifestEntries</code> 块就是 Manifest 的内容。在 maven 构建 jar 包的时候就会自动生成 Manifest 文件。</p><h4 id="自己创建"><a href="#自己创建" class="headerlink" title="自己创建"></a>自己创建</h4><p>可以在 resource 文件夹下手动创建一个名为 <code>MANIFEST.MF</code> 的文件，<strong>文件的最后一行必须为空行</strong>，内容形如：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Premain-Class: &lt;your_agent_class&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Agent-Class"><a href="#Agent-Class" class="headerlink" title="Agent Class"></a>Agent Class</h3><p>与以往的普通程序不同，javaagent的入口<strong>必须</strong>为 <code>premain</code> 函数，并且对函数签名也有要求，javaagent 仅接受两个签名的函数，分别为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种，优先加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String slotConfFilePath, Instrumentation inst)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String slotConfFilePath)</span></span><br></pre></td></tr></table></figure><p>jvm 优先加载含有 <code>Instrumentation</code> 签名的方法，如果没有<code>第一种</code>方法则会加载<code>第二种</code>方法。我们可以对 <code>Instrumentation</code> 进行操作以达到我们操作 class 文件的目的， <code>Instrumentation</code> 定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrumentation</span> &#123;</span><br><span class="line">    <span class="comment">//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="type">boolean</span> canRetransform)</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRetransformClassesSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRedefineClassesSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span> <span class="keyword">throws</span>  ClassNotFoundException, UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getInitiatedClasses(ClassLoader loader);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getObjectSize</span><span class="params">(Object objectToSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToSystemClassLoaderSearch</span><span class="params">(JarFile jarfile)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNativeMethodPrefixSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNativeMethodPrefix</span><span class="params">(ClassFileTransformer transformer, String prefix)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以操作 <code>premain</code> 方法中的 <code>Instrumentation</code> 对象来添加相关的操作。我们主要会用到 <code>addTransformer</code> 来添加转换类的实现，具体的为 <a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/transform/SlotTransformer.java">SlotTransformer</a></p><h3 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h3><p>在 Instrumentation 接口中，定义了添加和移除 ClassFileTransformer 的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrumentation</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="type">boolean</span> canRetransform)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ClassFileTransformer 接口中，定义了 transform 抽象方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] transform(ClassLoader         loader,</span><br><span class="line">                     String              className,</span><br><span class="line">                     Class&lt;?&gt;            classBeingRedefined,</span><br><span class="line">                     ProtectionDomain    protectionDomain,</span><br><span class="line">                     <span class="type">byte</span>[]              classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想对 Class 进行 bytecode instrumentation 时，就要实现 <code>ClassFileTransformer</code> 接口，并重写它的 <code>transform</code> 方法。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>javaagent</code> 主要以 <code>jar</code> 包的形式提供服务，并在使用 java 命令时以 <code>-javaagent:jar_path[=option]</code> 来启动服务，示例如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -javaagent:./target/TheAgent.jar -jar Demo.jar</span><br></pre></td></tr></table></figure><h2 id="埋点思路"><a href="#埋点思路" class="headerlink" title="埋点思路"></a>埋点思路</h2><h3 id="如何确定埋点范围"><a href="#如何确定埋点范围" class="headerlink" title="如何确定埋点范围"></a>如何确定埋点范围</h3><p>通过外部配置文件来指定。我们支持读取特定格式的 <code>properties</code> 文件解析出哪些方法需要进行埋点，<code>properties</code> 文件的路径通过 <code>-javaagent:/your/properties/file/path</code> 传递给 <code>premain</code> 的 <code>String</code> 参数。<a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/SlotAgentBootstrap.java">读取 <code>properties</code> 文件的方法</a>如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化埋点配置文件</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 本来初始化配置文件的操作在 &#123;<span class="doctag">@link</span> InitValve&#125; 中进行初始化，但现在需要对埋点日志的文件名按服务名进行划分，需要先获取到本次埋点</span></span><br><span class="line"><span class="comment">* 的服务名，所以提前到 &#123;<span class="doctag">@link</span> SlotAgentBootstrap&#125; 中进行</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> filePath 埋点配置文件路径</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 埋点配置文件 properties</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Properties <span class="title function_">init</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    AnsiLog.info(<span class="string">&quot;加载的配置文件路径为:&#123;&#125;&quot;</span>, filePath);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        prop = PropertiesUtils.loadExternalProp(filePath);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        AnsiLog.info(<span class="string">&quot;配置文件不存在，程序退出...&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取服务名称已初始化埋点日志名称</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> prop.getProperty(SLOT_SERVICE);</span><br><span class="line">    AnsiLog.debug(serviceName);</span><br><span class="line">    <span class="comment">// 初始化日志</span></span><br><span class="line">    SlotLogUtils.initLogger(serviceName);</span><br><span class="line">    <span class="keyword">return</span> prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="方法自身没有抛出异常"><a href="#方法自身没有抛出异常" class="headerlink" title="方法自身没有抛出异常"></a>方法自身没有抛出异常</h4><p>我们将目标方法代码块使用统一的 <code>try-cache</code> 进行处理，不论原方法是否抛出异常，我们都假定其会抛出异常，进行异常捕获并抛出。</p><blockquote><p>在一开始实现过程中并没有对所有方法都进行异常捕获，但是在 spring boot 程序测试中发现 spring boot 存在全局异常捕获机制导致埋点流程被打断，因为进行了异常抛出所以代码的后续被 spring boot 接管了，而不会沿着原本的业务进行下去，那么埋点逻辑处理的就不完整，埋点数据收集的不完整，所以需要全局捕获异常，强制代码块走到埋点逻辑的结束。</p></blockquote><p>例如原方法如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过全局异常处理之后变为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 埋点系统插入代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;<span class="comment">// 埋点系统插入代码</span></span><br><span class="line">        <span class="comment">// 埋点系统插入代码</span></span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;<span class="comment">// 埋点系统插入代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法自身抛出异常-处理异常"><a href="#方法自身抛出异常-处理异常" class="headerlink" title="方法自身抛出异常&#x2F;处理异常"></a>方法自身抛出异常&#x2F;处理异常</h4><p>如果方法自身抛出了异常或者对异常进行了处理，那么我们会在源代码的 <code>catch</code> 代码块中记录异常类型、异常信息和异常堆栈，以供后续分析。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">e</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过全局处理之后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 埋点系统插入代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 埋点系统插入代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 埋点系统插入代码</span></span><br><span class="line">    StackTraceElement[] var3 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 埋点系统插入代码</span></span><br><span class="line">        var1 = e.getClass.getName();</span><br><span class="line">        <span class="comment">// 埋点系统插入代码</span></span><br><span class="line">        var2 = e.getMessage();</span><br><span class="line">        <span class="comment">// 埋点系统插入代码</span></span><br><span class="line">        var3 = e.getStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">e</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法耗时计算、方法开始时间"><a href="#方法耗时计算、方法开始时间" class="headerlink" title="方法耗时计算、方法开始时间"></a>方法耗时计算、方法开始时间</h3><p>我们在方法代码块的最开始插入获取当前系统时间的时间戳和 <code>LocalDateTime</code> 来确定方法的开始时机，在方法的结尾、每个 <code>catch</code> 代码块中插入获取方法的结束时间代码并使用代码开始的时间戳减去方法结束的时间戳以获取方法的执行时间。</p><h3 id="埋点数据的处理"><a href="#埋点数据的处理" class="headerlink" title="埋点数据的处理"></a>埋点数据的处理</h3><p>为了埋点给系统带来最低的性能影响，埋点系统采用 <a href="https://github.com/LMAX-Exchange/disruptor"><code>disruptor</code></a> 消息中间件来处理埋点产生的埋点数据得到及时有效的处理。<a href="https://github.com/zenvzenv/slot/tree/main/slot-agent/src/main/java/zenv/slot/disruptor">源码在这</a></p><p>刚开始埋点系统采用的是 Java 自带的阻塞队列，发现存在性能问题和 OOM 问题，后期调研到 <code>disruptor</code> 组件，性能有了质的提升。在百万数据量下使用的内存和处理速度都有提升。</p><h3 id="字节码插桩"><a href="#字节码插桩" class="headerlink" title="字节码插桩"></a>字节码插桩</h3><p>slot 使用 ASM 字节码操作工具来对 Java 源码进行修改。JDK 自带的字节码操作框架无需额外引入框架，降低了 javaagent jar 包的体积。</p><p>ASM 是较为低级别的 API，使用和学习都存在一定的门槛，需要对 ClassFile 的结构有较深的理解和认识。</p><p>slot 是如何使用 ASM 进行字节码插桩的，可以参见<a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/asm/SlotMethodAroundWithDisruptorAdapter2.java">这里</a></p><h2 id="埋点思路与-javaagent-的结合"><a href="#埋点思路与-javaagent-的结合" class="headerlink" title="埋点思路与 javaagent 的结合"></a>埋点思路与 javaagent 的结合</h2><p>以上所有的思路全都依赖 <code>ClassFileTransformer</code> 中的 <code>transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer)</code> 方法来实现。特别的，slot 中的实现为 <a href="https://github.com/zenvzenv/slot/blob/main/slot-agent/src/main/java/zenv/slot/transform/SlotTransformer.java">SlotTransformer</a>。</p><p>我们主要会用到 loader、className 和 classfileBuffer 参数。</p><ol><li><p>loader 是当前被加载到 class 的类加载器，这个参数非常有用，我们需要使用该加载器来加载修改字节码之后的类，否则可能会出现 ClassNotFoundException</p><blockquote><p>特别的 spring boot 的 jar 包被称为 fat_jar，它内部的类加载机制由 spring 来控制，我们需要使用 spring 的类加载器来对修改后的类进行加载，否则会报 ClassNotFoundException</p></blockquote></li><li><p>className 用来与埋点配置文件中的配置项进行匹配，用来确定哪些类需要进行埋点，如果不似乎我们需要埋点的类那么可以直接返回 <code>null</code>，jvm 会自动加载原本的 class</p></li><li><p>classfileBuffer 存放了当前加载的 class 的字节码信息，我们使用 ASM 组件来操作字节码，插入我们需要的埋点字节码</p></li></ol><p>jvm 保证在 transform 的过程如果出现异常的话最终加载的是未经修改的 class。</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><ol><li>对于跨进程和跨机器的集群服务支持埋点服务</li><li>可以更换为 attach api 来热更新埋点配置</li><li>目前只能通过配置文件的方式来指定埋点的范围，可以考虑使用 jar 包探测，探测目标工程为 spring boot、netty、grpc或其他工程来确定埋点范围</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://lsieun.github.io/java-agent/java-agent-01.html">Java Agent系列一：基础篇</a></li></ol>]]></content>
    
    
    <summary type="html">Java javaagent 无痕埋点思路</summary>
    
    
    
    
    <category term="埋点" scheme="https://zenvzenv.github.io/tags/%E5%9F%8B%E7%82%B9/"/>
    
    <category term="java" scheme="https://zenvzenv.github.io/tags/java/"/>
    
    <category term="javaagent" scheme="https://zenvzenv.github.io/tags/javaagent/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Butterfly+GitHubPages 搭建个人博客</title>
    <link href="https://zenvzenv.github.io/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://zenvzenv.github.io/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-03-20T11:19:12.000Z</published>
    <updated>2023-03-20T11:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你可能会问本站是怎么来的？<br>既然你诚心诚意的发文了，那我就大发慈悲的告诉你！</p></blockquote><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><p>前去 <a href="https://git-scm.com/downloads">gitbash 官网</a> 根据自己的系统下载 <code>gitbash</code>。</p><p>如果你从未安装过 gitbash，那么在安装过程中只要一路默认即可，需要注意的是软件的安装路径；如果你安装过 gitbash，那么就按自己的喜好进行安装即可。</p><p>当你已经安装好 gitbash 后，我们还需要一些必要的配置，请到工作目录右键选择 <code>Git bash here</code> 来启动 gitbash，并在终端执行如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 Git 用户名：</span></span><br><span class="line">git config --global user.name &quot;your github username&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认您正确设置了 Git 用户名：</span></span><br><span class="line">git config --global user.name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 Git Email：</span></span><br><span class="line">git config --global user.email &quot;your github email&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认在 Git 中正确设置了电子邮件地址：</span></span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure><h4 id="配置-GitHub-密钥"><a href="#配置-GitHub-密钥" class="headerlink" title="配置 GitHub 密钥"></a>配置 GitHub 密钥</h4><p>如果已经配置过密钥可以跳过</p><ol><li>首先打开 gitbash 终端执行如下命令生成本地密钥</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>之后一路回车即可。命令执行完毕之后会生成 <code>~/.ssh/</code> 目录，目录下有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，将 <code>id_rsa.pub</code> 文件中的内容复制到 GitHub 中。</p><p><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/setting.png" alt="setting"><br><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ssh_and_gpg_keys.png" alt="ssh_and_gpg_keys"><br><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/new_ssh_key.png" alt="new_ssh_key"><br><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/add_ssh_key.png" alt="add_ssh_key"></p><h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><p>前去 <a href="https://nodejs.org/en/download">nodejs 官网</a> 下载自己系统对应版本的 LTS nodejs。安装过程一直默认下一步即可，需要注意的就是 nodejs 安装的路径。</p><p>安装完毕之后需要确认 nodejs 是否安装成功，可以打开 gitbash 终端来进行确认，打开 gitbash 终端之后输入如下命令来确认：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 nodejs 版本</span></span><br><span class="line">node -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 npm 版本</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/nodejs_install_success.png" alt="nodejs_install_success"></p><p>如果以上命令能够正确输出版本号即表明 nodejs 安装成功。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>打开 gitbash 终端，输入 Hexo 安装命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure><p>安装过程可能会比较长，请耐心等待。安装成功后可以输入如下命令来验证 Hexo 是否安装过。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure><p><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_install_success.png" alt="hexo_install_success"></p><p>当安装成功后我们可以使用如下命令来生成一个空的博客框架</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完毕之后目标文件夹的目录结构如下所示：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>使用 <code>hexo s</code> 来启动博客服务并在本地访问 <code>http://localhost:4000/</code> 来访问博客。</p><h3 id="安装-butterfly"><a href="#安装-butterfly" class="headerlink" title="安装 butterfly"></a>安装 butterfly</h3><p>在 Hexo 生成的博客的根目录，执行如下命令来安装 butterfly 主题。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line">npm install hexo-theme-butterfly</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure><p>并将根目录下的 <code>_config.yml</code> 中的 <code>theme</code> 改为 <code>butterfly</code>，然后启动 Hexo 即可看到主题效果。你也可以进行一些<a href="https://butterfly.js.org/posts/21cfbf15/">配置</a>来个性化主题</p><h2 id="创建-GitHub-Repository"><a href="#创建-GitHub-Repository" class="headerlink" title="创建 GitHub Repository"></a>创建 GitHub Repository</h2><p>登录自己的 GitHub 账号并创建一个形如 <code>your_user_name.github.io</code> (其中 <code>your_user_name</code> 是你的 GitHub 用户名)的<strong>公共</strong>仓库和一个存放博客源码的<strong>私有</strong>仓库，私有仓库名字随意。</p><p>私有仓库是为了保护源码不泄露，当私有博客仓库编译渲染完毕之后会将最终页面 push 到 <code>your_user_name.github.io</code> 仓库中，以达到展示的目的和保护源码的目的。</p><p>公共仓库 <code>your_user_name.github.io</code> 是为了存放博客的最终编译完毕的文件，通过 GitHubPages 来对外进行展示。</p><p>共有仓库和私有仓库通过 GitHub Token 来进行联系。</p><p><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/new_repo.png" alt="new_repo"></p><h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><p>找到博客的工作目录，右键打开 gitbash 终端，初始化一个 Hexo 博客。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;your_blog_name&gt;</span><br><span class="line">cd &lt;your_blog_name&gt;</span><br><span class="line">npm install</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line">rm -rf themes/butterfly/.git</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是我们需要把 butterfly 的 <code>.git</code> 目录删除，因为会和我们博客仓库的 <code>.git</code> 冲突导致页面渲染失败。</p></blockquote><p>至此，博客就创建了出来，随后我们需要将源文件上传到私有仓库中。</p><h2 id="上传源码"><a href="#上传源码" class="headerlink" title="上传源码"></a>上传源码</h2><p>我们可以使用如下命令将博客源码上传到 GitHub 仓库中。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &lt;your_blog_name&gt;</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init my blog&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin &lt;your_github_repo&gt;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h3 id="生成-GitHub-Token"><a href="#生成-GitHub-Token" class="headerlink" title="生成 GitHub Token"></a>生成 GitHub Token</h3><p>我们可以在个人设置中创建 token</p><p><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/setting.png" alt="setting"><br><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/new_github_token.png" alt="new_github_token"></p><p>我们需要给 token 赋予 <code>repo</code> 和 <code>workflow</code> 权限；建议设置90天的有效期；<strong>将 token 复制下来</strong>，否则忘记的话还需要重新生成。</p><p><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/new_personal_token.png" alt="new_personal_token"></p><h3 id="设置-GitHub-Token"><a href="#设置-GitHub-Token" class="headerlink" title="设置 GitHub Token"></a>设置 GitHub Token</h3><blockquote><p>设置 Token 是为了将私有博客仓库中编译出来的博客页面能够 push 到 <code>your_user_name.github.io</code> 仓库中，以达到源码不泄露的目的。</p></blockquote><p>打开私有博客仓库的 <code>Setting</code></p><p><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/private_secrets_setting.png" alt="private_secrets_setting"><br><img src="/2023/03/20/Hexo-Butterfly-GitHubPages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/private_new_secret.png" alt="private_new_secret"></p><h2 id="创建-workflow"><a href="#创建-workflow" class="headerlink" title="创建 workflow"></a>创建 workflow</h2><p>在博客的根目录下创建 <code>.github/workflow/hexo-deploy.yml</code> 文件(文件名无所谓，但路径必须是这个路径)。在 <code>hexo-deploy.yml</code> 文件中写入一下内容：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># default branch</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span> </span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build</span> <span class="string">and</span> <span class="string">deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">theme-keep/hexo-deploy-github-pages-action@master</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">PERSONAL_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">PUBLISH_REPOSITORY:</span> <span class="string">&lt;your</span> <span class="string">github</span> <span class="string">repo&gt;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">main</span></span><br><span class="line">          <span class="attr">PUBLISH_DIR:</span> <span class="string">./public</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>以上 yml 文件只需要修改 <code>PUBLISH_REPOSITORY</code> 为你自己的仓库即可，此仓库必须为 <code>your_user_name.github.io</code>。</p><p>具体配置请参阅 <a href="https://docs.github.com/en/actions">GitHub Action</a>。</p><p>此处使用了 <code>hexo-deploy-github-pages-action</code> Action 插件，可以前去 <a href="git@github.com:theme-keep/hexo-deploy-github-pages-action.git">theme-keep&#x2F;hexo-deploy-github-pages-action</a>查看具体用法。后面可能也会写一篇文章来介绍下 GitHub Action。</p><p>创建好 <code>.github/workflow/hexo-deploy.yml</code> 之后，将其上传到 GitHub 中，GitHub 会自动触发构建任务，来对博客进行构建。具体的，可以在私有博客仓库的 Action 中进行查看。构建完成后会自动将构建好的工程 push 到 <code>your_user_name.github.io</code> 仓库中进行 GitHubPages 部署，待 GitHubPages 部署完毕之后通过 <code>https://your_user_name.github.io</code> 来访问博客。</p><p>至此博客基本搭建完毕。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>如遇到什么问题可以与我取得联系，虽然我也可能不会，但我会尽力解答(^^ゞ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;你可能会问本站是怎么来的？&lt;br&gt;既然你诚心诚意的发文了，那我就大发慈悲的告诉你！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前置准备&quot;&gt;&lt;a href=&quot;#前置准备&quot; class=&quot;headerlink&quot; title=&quot;前置准备&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://zenvzenv.github.io/tags/hexo/"/>
    
    <category term="教程" scheme="https://zenvzenv.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
